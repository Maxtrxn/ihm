début fichier ./src/common/JsonReaderException.java
package src.common;

public class JsonReaderException extends RuntimeException {
    public JsonReaderException() {
        super();
    }

    public JsonReaderException(String message) {
        super(message);
    }

    public JsonReaderException(String message, Throwable cause) {
        super(message, cause);
    }

    public JsonReaderException(Throwable cause) {
        super(cause);
    }
}
fin fichier ./src/common/JsonReaderException.java





début fichier ./src/common/JsonReader.java
package src.common;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Scanner;
import org.json.JSONObject;

import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.stage.FileChooser;
import javafx.stage.Stage;

public class JsonReader {
    //Méthode pour lire un fichier JSON
    private static String readJsonFile(String filePath) {
        StringBuilder content = new StringBuilder();
        try {
            File file = new File(filePath);
            Scanner scanner = new Scanner(file);
            while (scanner.hasNextLine()) {
                content.append(scanner.nextLine());
            }
            scanner.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return null;
        }
        return content.toString();
    }

    public static JSONObject getJsonObjectContent(String filePath){
        String jsonContent = readJsonFile(filePath);
        
        if(jsonContent == null){
            javafx.application.Platform.exit();
        }   
        
        return new JSONObject(jsonContent);
    }


    public static boolean saveJsonObject(JSONObject object, String filePath, boolean overwrite) throws JsonReaderException{
        File level = new File(filePath);
        if(!overwrite && level.exists()){
            return false;
        }

        try (FileWriter file = new FileWriter(level)) {
            file.write(object.toString(4));
            file.flush();
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }
}
fin fichier ./src/common/JsonReader.java





début fichier ./src/common/ResourceManager.java
package src.common;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Locale;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;

import org.json.JSONObject;

import javafx.scene.image.Image;

public class ResourceManager {
    public static final String RESOURCE_FOLDER = "../resources/";
    public static final String LEVELS_FOLDER = RESOURCE_FOLDER + "levels/";
    public static final String STYLESHEET_FOLDER = RESOURCE_FOLDER + "css/";
    public static final String TEXTURES_FOLDER = RESOURCE_FOLDER + "textures/";
    public static final String PLATFORMS_FOLDER = TEXTURES_FOLDER + "platforms/";
    public static final String DECORATIONS_FOLDER = TEXTURES_FOLDER + "decorations/";
    public static final String ENEMIES_FOLDER = TEXTURES_FOLDER + "enemies/";
    public static final String BACKGROUNDS_FOLDER = TEXTURES_FOLDER + "backgrounds/";


    public static int resolutionWidth = 1280;
    public static int resolutionHeight = 720;


    public static final JSONObject DECORATIONS_JSON = JsonReader.getJsonObjectContent(ResourceManager.RESOURCE_FOLDER + "decorations.json");
    public static final JSONObject ENEMIES_JSON = JsonReader.getJsonObjectContent(ResourceManager.RESOURCE_FOLDER + "enemies.json");
    public static final JSONObject PLATFORMS_JSON = JsonReader.getJsonObjectContent(ResourceManager.RESOURCE_FOLDER + "platforms.json");

    public static final String DEFAULT_TEXTURE = TEXTURES_FOLDER + "default.png";


    private static Locale currentLocale;
    private static ResourceBundle bundle;

    public static void setLocale(Locale locale) {
        currentLocale = locale;
        loadBundleFromFile(locale);
    }
    public static Locale getLocale() {return currentLocale;}
    public static String getString(String key) {
        if (bundle != null && bundle.containsKey(key)) {
            return bundle.getString(key);
        } else {
            return "!" + key + "!";
        }
    }

    private static void loadBundleFromFile(Locale locale) {
        String langCode = locale.getLanguage();
        String filePath = "../resources/text/text_" + langCode + ".properties";

        try (FileInputStream fis = new FileInputStream(filePath);
             InputStreamReader reader = new InputStreamReader(fis, "UTF-8")) {
            bundle = new PropertyResourceBundle(reader);
        } catch (IOException e) {
            System.err.println("Impossible de charger les fichiers de langue : " + filePath);
            bundle = null;
        }
    }
}
fin fichier ./src/common/ResourceManager.java





début fichier ./src/controller/editor/EditorLevelObjectSelectorController.java
package src.controller.editor;

import javafx.scene.layout.VBox;
import src.model.editor.GameEditorModel;
import src.view.editor.EditorLevelObjectSelectorView;

public class EditorLevelObjectSelectorController {
    private GameEditorModel model;
    private EditorLevelObjectSelectorView view;


    public EditorLevelObjectSelectorController(GameEditorModel model){
        this.model = model;
        this.view = new EditorLevelObjectSelectorView(this);
    }
    

    public VBox getRegion(){return this.view.getRegion();}

    public void handleSelectedLevelObjectChange(String levelObjectName){
        this.model.setSelectedLevelObjectName(levelObjectName);
    }
}
fin fichier ./src/controller/editor/EditorLevelObjectSelectorController.java





début fichier ./src/controller/editor/EditorMenuBarController.java
package src.controller.editor;

import java.io.File;
import java.util.Optional;

import javafx.application.Platform;
import javafx.scene.Scene;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.Button;
import javafx.scene.control.ButtonType;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.control.Spinner;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.FileChooser;
import javafx.stage.Modality;
import javafx.stage.Stage;
import src.common.ResourceManager;
import src.controller.game.GameController;
import src.model.editor.GameEditorModel;
import src.view.editor.EditorMenuBarView;

public class EditorMenuBarController {
    private GameEditorModel model;
    private EditorMenuBarView view;
    private Stage stage;

    public EditorMenuBarController(GameEditorModel model, Stage stage){
        this.model = model;
        this.stage = stage;
        this.view = new EditorMenuBarView(this);

        this.view.getMenuItem(null);
    }

    public EditorMenuBarView getEditorMenuBarView(){
        return this.view;
    }


    // --- File Menu Items ---

    public void handleFileNewLevel(){
        Stage newWindow = new Stage();

        //Les champs input
        Label levelNameLabel = new Label(ResourceManager.getString("new_level_name_label"));
        TextField levelName = new TextField();


        Label levelHeightLabel = new Label(ResourceManager.getString("new_level_height_label"));
        Spinner<Integer> levelHeight = new Spinner<>(128, 1280, 640, 128);
        levelHeight.setEditable(true);
        levelHeight.valueProperty().addListener((observable, oldValue, newValue) -> {
            if ((newValue - 128) % 128 != 0) {
                int correctedValue = ((newValue - 128) / 128) * 128 + 128;
                levelHeight.getValueFactory().setValue(correctedValue);
            }
        });

        Label levelWidthLabel = new Label(ResourceManager.getString("new_level_width_label"));
        Spinner<Integer> levelWidth = new Spinner<>(128, 12800, 6400, 128);
        levelWidth.setEditable(true);
        levelWidth.valueProperty().addListener((observable, oldValue, newValue) -> {
            if ((newValue - 128) % 128 != 0) {
                int correctedValue = ((newValue - 128) / 128) * 128 + 128;
                levelWidth.getValueFactory().setValue(correctedValue);
            }
        });

        //Les boutons
        HBox buttons = new HBox(10);
        Button createButton = new Button(ResourceManager.getString("create_button"));
        createButton.setOnAction(e -> {
            this.model.initLevel(levelName.getText(), levelWidth.getValue(), levelHeight.getValue());
            newWindow.close();
        });
        Button cancelButton = new Button(ResourceManager.getString("cancel_button"));
        cancelButton.setOnAction(e -> {
            newWindow.close();
        });
        buttons.getChildren().addAll(createButton, cancelButton);
        buttons.setStyle("-fx-padding: 10; -fx-alignment: center;");

        //Paramètres de la fenêtre
        VBox layout = new VBox(10, levelNameLabel, levelName, levelHeightLabel, levelHeight, levelWidthLabel, levelWidth, buttons);
        layout.setStyle("-fx-padding: 10; -fx-alignment: center;");
        Scene scene = new Scene(layout, 450, 400);

        newWindow.initModality(Modality.APPLICATION_MODAL);
        newWindow.setScene(scene);
        newWindow.setTitle(ResourceManager.getString("new_level_window_title"));
        newWindow.showAndWait();
    }

    public void handleFileOpenLevel(){
        final String[] levelName = {null};
        Stage window = new Stage();
        window.initModality(Modality.APPLICATION_MODAL);
        window.setTitle(ResourceManager.getString("file_open_level"));

        ListView<String> listView = new ListView<>();
        File directory = new File(ResourceManager.LEVELS_FOLDER);
        if (directory.exists() && directory.isDirectory()) {
            for (File file : directory.listFiles()) {
                if (file.isFile()) {
                    String fileName = file.getName();
                    listView.getItems().add(fileName.substring(0, fileName.lastIndexOf('.')));
                }
            }
        }

        Button selectButton = new Button(ResourceManager.getString("select_button"));
        selectButton.setOnAction(e -> {
            levelName[0] = listView.getSelectionModel().getSelectedItem();
            window.close();
        });
        Button cancelButton = new Button(ResourceManager.getString("cancel_button"));
        cancelButton.setOnAction(e -> {window.close();});

        HBox buttons = new HBox(10, selectButton, cancelButton);
        VBox layout = new VBox(10, listView, buttons);
        Scene scene = new Scene(layout, 400, 400);
        window.setScene(scene);
        window.showAndWait();

        if(levelName[0] != null){
            this.model.loadLevel(levelName[0]);
        }
    }

    public void handleFileSaveLevel(){
        Alert alert;
        if(this.model.saveLevel(false)){ //Si le fichier existe déjà
            alert = new Alert(AlertType.INFORMATION);
            alert.setTitle(ResourceManager.getString("info_title"));
            alert.setHeaderText(ResourceManager.getString("Level_save_success"));
            alert.setContentText(ResourceManager.getString("Level_save_folder"));
            alert.showAndWait();
        }else{
            alert = new Alert(Alert.AlertType.CONFIRMATION);
            alert.setTitle(ResourceManager.getString("Level_save_confirm_title"));
            alert.getButtonTypes().setAll(ButtonType.YES, ButtonType.NO);
            alert.setContentText(ResourceManager.getString("level_save_overwrite"));
            Optional<ButtonType> result = alert.showAndWait();
            if (result.isPresent()) {
                if (result.get() == ButtonType.YES) {
                    this.model.saveLevel(true);
                }
            }  
        }
    }

    public void handleFileDeleteLevel(){
        final String[] levelName = {null};
        Stage window = new Stage();
        window.initModality(Modality.APPLICATION_MODAL);
        window.setTitle(ResourceManager.getString("file_delete_level"));

        ListView<String> listView = new ListView<>();
        File directory = new File(ResourceManager.LEVELS_FOLDER);
        if (directory.exists() && directory.isDirectory()) {
            for (File file : directory.listFiles()) {
                if (file.isFile()) {
                    String fileName = file.getName();
                    listView.getItems().add(fileName.substring(0, fileName.lastIndexOf('.')));
                }
            }
        }

        Button selectButton = new Button(ResourceManager.getString("select_button"));
        selectButton.setOnAction(e -> {
            levelName[0] = listView.getSelectionModel().getSelectedItem();
            window.close();
        });
        Button cancelButton = new Button(ResourceManager.getString("cancel_button"));
        cancelButton.setOnAction(e -> {window.close();});

        HBox buttons = new HBox(10, selectButton, cancelButton);
        VBox layout = new VBox(10, listView, buttons);
        Scene scene = new Scene(layout, 400, 400);
        window.setScene(scene);
        window.showAndWait();

        if(levelName[0] != null){
            this.model.deleteLevel(levelName[0]);
        }
    }

    public void handleFileQuit(){
        Platform.exit();
    }

    



    // --- Level Menu Items ---

    public void handleLevelChangeLevelName(){
        if(this.model.getLevel() == null){
            Alert alert = new Alert(AlertType.INFORMATION);
            alert.setTitle(ResourceManager.getString("info_title"));
            alert.setHeaderText(null);
            alert.setContentText(ResourceManager.getString("level_name_change_error"));
            alert.showAndWait();
            return;
        }

        Stage newWindow = new Stage();
        newWindow.initModality(Modality.APPLICATION_MODAL);


        Label levelNameLabel = new Label(ResourceManager.getString("level_name_change_label"));
        TextField levelName = new TextField();

        HBox buttons = new HBox();
        Button createButton = new Button(ResourceManager.getString("confirm_button"));
        createButton.setOnAction(e -> {
            this.model.setLevelName(levelName.getText());
            newWindow.close();
        });
        Button cancelButton = new Button(ResourceManager.getString("cancel_button"));
        cancelButton.setOnAction(e -> {
            newWindow.close();
        });
        buttons.getChildren().addAll(createButton, cancelButton);
        buttons.setStyle("-fx-padding: 10; -fx-alignment: center;");


        VBox layout = new VBox(10, levelNameLabel, levelName, buttons);
        layout.setStyle("-fx-padding: 10; -fx-alignment: center;");

        Scene scene = new Scene(layout, 300, 200);
        newWindow.setScene(scene);
        newWindow.setTitle(ResourceManager.getString("Level_name_change_title"));
        newWindow.showAndWait();
    }

    public void handleLevelChangeLevelBackground(){
        if(this.model.getLevel() == null){
            Alert alert = new Alert(AlertType.INFORMATION);
            alert.setTitle(ResourceManager.getString("info_title"));
            alert.setHeaderText(null);
            alert.setContentText(ResourceManager.getString("level_background_error"));
            alert.showAndWait();
            return;
        }

        //On créer un sélecteur de fichier
        FileChooser fileChooser = new FileChooser();
        fileChooser.setTitle(ResourceManager.getString("level_background_title"));

        //On ajoute un filtre au sélecteur de fichier pour n'avoir que des images
        fileChooser.getExtensionFilters().addAll(
            new FileChooser.ExtensionFilter("Images", "*.png", "*.jpg", "*.jpeg", "*.gif", "*.bmp")
        );


        //On ouvre la fenêtre du sélecteur de fichier
        File selectedFile = fileChooser.showOpenDialog(null);
        if(selectedFile != null){
            //On transforme le fichier choisi en instance d'Image et on calcule sa nouvelle hauteur pour qu'elle soit la
            //même que celle de la fentre du niveau (GridPane) en calculant aussi proportionnellement sa largeur 
            Image image = new Image(selectedFile.toURI().toString());
            
            this.model.setLevelBackground(image);
        }
    }

    public void handleLevelTestLevel(){
        if(this.model.getLevel() != null){
            String levelName = this.model.getLevelName();
            this.model.setLevelName("temp");
            this.model.saveLevel(true);
            this.model.setLevelName(levelName);

            Stage gameStage = new Stage();
            gameStage.initModality(Modality.APPLICATION_MODAL);
            gameStage.setTitle(ResourceManager.getString("level_test"));
            new GameController(gameStage, "temp");
            gameStage.showAndWait();
        }else{
            Alert alert = new Alert(AlertType.INFORMATION);
            alert.setTitle(ResourceManager.getString("info_title"));
            alert.setHeaderText(null);
            alert.setContentText(ResourceManager.getString("level_test_info"));
            alert.showAndWait();
            return;
        } 
    }



    // --- Preferences Menu Items ---
    public void handlePreferenceEditorTheme(){
        final String[] cssFileName = {null};
        Stage window = new Stage();
        window.initModality(Modality.APPLICATION_MODAL);
        window.setTitle(ResourceManager.getString("preferences_editor_theme_title"));

        ListView<String> listView = new ListView<>();
        File directory = new File(ResourceManager.STYLESHEET_FOLDER);
        if (directory.exists() && directory.isDirectory()) {
            for (File file : directory.listFiles()) {
                if (file.isFile()) {
                    String fileName = file.getName();
                    listView.getItems().add(fileName);
                }
            }
        }

        Button selectButton = new Button(ResourceManager.getString("select_button"));
        selectButton.setOnAction(e -> {
            cssFileName[0] = listView.getSelectionModel().getSelectedItem();
            window.close();
        });
        Button cancelButton = new Button(ResourceManager.getString("cancel_button"));
        cancelButton.setOnAction(e -> {window.close();});

        HBox buttons = new HBox(10, selectButton, cancelButton);
        VBox layout = new VBox(10, listView, buttons);
        Scene scene = new Scene(layout, 400, 400);
        window.setScene(scene);
        window.showAndWait();

        if(cssFileName[0] != null){
            this.stage.getScene().getStylesheets().clear();
            this.stage.getScene().getStylesheets().add(getClass().getResource("/css/" + cssFileName[0]).toString());
        }
    }
}

fin fichier ./src/controller/editor/EditorMenuBarController.java





début fichier ./src/controller/editor/GameEditorController.java
package src.controller.editor;


import java.beans.PropertyChangeEvent;


import javafx.stage.Stage;
import src.common.ResourceManager;
import src.model.editor.GameEditorModel;
import src.model.game.Level;
import src.view.editor.GameEditorView;


public class GameEditorController{
    public enum LevelObjectType {
        PLATFORM, FRAGILE_PLATFORM, DECORATION, ENEMY, BOSS, SPAWNPOINT;
    }
    private GameEditorModel model = null;
    private GameEditorView view = null;
    private Stage stage;
    

    public GameEditorController(Stage stage) {
        this.model = new GameEditorModel(this);
        this.view = new GameEditorView(this, stage);
        this.stage = stage;

        EditorMenuBarController menuBarMVC = new EditorMenuBarController(this.model, stage);
        this.view.setTop(menuBarMVC.getEditorMenuBarView());


        this.model.addPropertyChangeListener("changeLevelName", e -> {stage.setTitle("Steampunk Adventure - "+ ResourceManager.getString("editor_title_name") + " - " + e.getNewValue());});
        this.model.addPropertyChangeListener("initLevel", e -> handleInitLevel(e));
    }

    public GameEditorModel getModel(){return this.model;}
    public GameEditorView getView(){return this.view;}


    public void handleInitLevel(PropertyChangeEvent e){
        MapEditorController mapEditorMVC = new MapEditorController(model, (Level)e.getNewValue(), this.stage);

        this.view.setCenter(mapEditorMVC.getMapEditorRegion());
        this.view.setBottom(mapEditorMVC.getMapEditorSettingsRegion());

        EditorLevelObjectSelectorController levelObjectSelectorMVC = new EditorLevelObjectSelectorController(model);
        this.view.setLeft(levelObjectSelectorMVC.getRegion());
    }
}fin fichier ./src/controller/editor/GameEditorController.java





début fichier ./src/controller/editor/MapEditorController.java
package src.controller.editor;

import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.Spinner;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Modality;
import javafx.stage.Stage;
import src.common.ResourceManager;
import src.controller.editor.GameEditorController.LevelObjectType;
import src.model.editor.GameEditorModel;
import src.model.game.Level;
import src.model.game.LevelObject;
import src.model.game.Platform;
import src.model.game.platforms.SpawnPoint;
import src.view.editor.MapEditorView;

public class MapEditorController {
    private GameEditorModel model;
    private MapEditorView view;
    private Stage stage;

    public MapEditorController(GameEditorModel model, Level level, Stage stage){
        this.model = model;
        this.view = new MapEditorView(this, level);
        this.stage = stage;

        this.model.addPropertyChangeListener("changeLevelData", e -> {
            this.model.setClickSelectedLevelObject(null);
            this.view.updateClickSelectedLevelObject(null);
            this.view.showLevel((Level)e.getNewValue());
        });
        this.model.addPropertyChangeListener("changeSelectedLevelObjectName", e -> {
            model.setClickSelectedLevelObject(null);
            view.updateClickSelectedLevelObject(null);
            this.view.updateSelectedLevelObjectImage((String)e.getNewValue());
        });

    }

    ScrollPane getMapEditorRegion(){return this.view.getMainRegion();}
    HBox getMapEditorSettingsRegion(){return this.view.getSettingsRegion();}


    public void addPlatform(double x, double y){this.model.addPlatform(x, y);}
    public void addDecoration(double x, double y, boolean foreground){this.model.addDecoration(x, y, foreground);}
    public void addEnemy(double x, double y, double leftBound, double rightBound, double speed){this.model.addEnemy(x, y, leftBound, rightBound, speed);}


    public void handleMouseClick(double cellTopLeftX, double cellTopLeftY){
        if(this.model.getSelectedLevelObjectName() == null){
            //Si il n'y a pas d'objet sélectionné dans le listview
            handleObjectSelectionOrDeletion(cellTopLeftX, cellTopLeftY);
        }else{
            //Si il y a un objet sélectionné dans le listview
            handleObjectPlacement(cellTopLeftX, cellTopLeftY);
        }
    }



    private void handleObjectSelectionOrDeletion(double x, double y) {
        LevelObject onPos = model.getLevelObjectAt(x, y);
    
        LevelObject newSelection = null;

        if (onPos == null) {
            //Clic dans le vide -> désélection
        } else if (onPos == model.getClickSelectedLevelObject()) {
            //Deucième clic sur un objet -> suppression
            model.removeLevelObject(onPos);
        } else {
            //Sélection d'un nouvel objet
            newSelection = onPos;
        }

        model.setClickSelectedLevelObject(newSelection);
        view.updateClickSelectedLevelObject(newSelection);
    }



    private void handleObjectPlacement(double x, double y) {
        //Si il y a déjà un level object à l'endroit où on a cliqué, on ne l'ajoute pas,
        //C'est plus simple pour gérer la selection avec un clique d'un objet placé.
        if(model.getLevelObjectAt(x, y) != null) return;
    
        String name = model.getSelectedLevelObjectName();
    
        if(ResourceManager.PLATFORMS_JSON.has(name)){
            LevelObjectType type = LevelObjectType.valueOf(ResourceManager.PLATFORMS_JSON.getJSONObject(name).getString("type"));
            switch (type) {
                case SPAWNPOINT -> model.setSpawnPoint(x, y);
                case FRAGILE_PLATFORM, PLATFORM -> model.addPlatform(x, y);
            }
        }else if(ResourceManager.DECORATIONS_JSON.has(name)){
            model.addDecoration(x, y, false);
        }else if(ResourceManager.ENEMIES_JSON.has(name)){
            handleEnemyPlacement(x, y);
        }
    }




    private void handleEnemyPlacement(double levelObjectX, double levelObjectY){
        Stage newWindow = new Stage();
        newWindow.initModality(Modality.APPLICATION_MODAL);

        Label leftPatrolDistanceLabel = new Label(ResourceManager.getString("handleEnemyPlacement_leftPatrolDistanceLabel"));
        Spinner<Integer> leftPatrolDistanceSelection = new Spinner<>(0, 200, 100, 1);
        leftPatrolDistanceSelection.setEditable(true);

        Label rightPatrolDistanceLabel = new Label(ResourceManager.getString("handleEnemyPlacement_rightPatrolDistanceLabel"));
        Spinner<Integer> rightPatrolDistanceSelection = new Spinner<>(0, 200, 100, 1);
        rightPatrolDistanceSelection.setEditable(true);

        Label speedLabel = new Label(ResourceManager.getString("handleEnemyPlacement_speedLabel"));
        Spinner<Integer> speedSelection = new Spinner<>(0, 200, 60, 1);
        speedSelection.setEditable(true);

        HBox buttons = new HBox();
        Button createButton = new Button(ResourceManager.getString("confirm_button"));
        createButton.setOnAction(e -> {
            double leftBound = leftPatrolDistanceSelection.getValue();
            double rightBound = rightPatrolDistanceSelection.getValue();
            double speed = speedSelection.getValue();
            this.model.addEnemy(levelObjectX, levelObjectY, levelObjectX - leftBound, levelObjectX + rightBound, speed);
            newWindow.close();
        });
        Button cancelButton = new Button(ResourceManager.getString("cancel_button"));
        cancelButton.setOnAction(e -> {
            newWindow.close();
        });
        buttons.getChildren().addAll(createButton, cancelButton);
        buttons.setStyle("-fx-padding: 10; -fx-alignment: center;");


        VBox layout = new VBox(10, leftPatrolDistanceLabel, leftPatrolDistanceSelection, rightPatrolDistanceLabel,
        rightPatrolDistanceSelection, speedLabel, speedSelection, buttons);
        layout.setStyle("-fx-padding: 10; -fx-alignment: center;");

        Scene scene = new Scene(layout, 300, 400);
        scene.getStylesheets().add(this.stage.getScene().getStylesheets().getFirst());
        newWindow.setScene(scene);
        newWindow.setTitle(ResourceManager.getString("handleEnemyPlacement_window_title"));
        newWindow.showAndWait();
    }


}
fin fichier ./src/controller/editor/MapEditorController.java





début fichier ./src/controller/game/GameController.java
// src/controller/game/GameController.java
package src.controller.game;

import java.util.ArrayList;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import javafx.animation.AnimationTimer;
import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
import javafx.stage.Stage;
import javafx.scene.image.Image;

import src.model.game.Boss;
import src.model.game.Decoration;
import src.model.game.Enemy;
import src.model.game.GameModel;
import src.model.game.Level;
import src.model.game.Platform;
import src.model.game.Player;
import src.model.game.Projectile;
import src.view.game.GameView;

public class GameController {
    private static final double GRAVITY               = 1800.0;
    private static final double SHIP_SCROLL_SPEED     = 200.0; // px/s
    private static final int    MAX_LIVES             = 3;
    private static final double INVINCIBLE_DURATION   = 1.0;   // seconds

    // Input flags
    private boolean left, right, up, down, jumping, jetpack;

    private Player                   player;
    private List<Platform>           platforms;
    private List<Enemy>              enemies;
    private List<Decoration>         decorations;
    private final List<Projectile>   projectiles = new ArrayList<>();
    private final GameView           view;
    private final GameModel          model;
    private Level                    level;

    private double initialPlayerX, initialPlayerY;
    private Timer  jetpackTimer;

    // Camera
    private double cameraX = 0, cameraY = 0;

    // Boss fight
    private boolean inBossFight = false;

    // Lives & invincibility
    private int     lives           = MAX_LIVES;
    private boolean invincible      = false;
    private double  invincibleTimer = 0;

    // Main loop
    private AnimationTimer gameLoop;

    public GameController(Stage primaryStage) {
        this.view  = new GameView(this, primaryStage);
        this.model = new GameModel(this);
        updateLivesDisplay();
    }

    public GameController(Stage primaryStage, String levelName) {
        this.view  = new GameView(this, primaryStage);
        this.model = new GameModel(this, levelName);
        updateLivesDisplay();
    }

    /** Sets the player and its respawn point. */
    public void setPlayer(Player player) {
        this.player = player;
        this.initialPlayerX = player.getX();
        this.initialPlayerY = player.getY();
    }

    /** Loads a new level and resets lives. */
    public void setLevel(Level level) {
        this.level       = level;
        this.platforms   = level.getPlatforms();
        this.enemies     = level.getEnemies();
        this.decorations = level.getDecorations();

        // Reset lives at start of level
        lives = MAX_LIVES;
        invincible = false;
        updateLivesDisplay();
    }

    /** Binds keyboard input to movement flags and actions. */
    public void handleInput() {
        Scene scene = view.getScene();
        scene.setOnKeyPressed(e -> {
            boolean isShip = level.getPlatforms().isEmpty() && level.getEnemies().isEmpty();

            if (e.getCode() == KeyCode.LEFT || e.getCode() == KeyCode.Q)  left  = true;
            if (e.getCode() == KeyCode.RIGHT || e.getCode() == KeyCode.D) right = true;
            if (e.getCode() == KeyCode.UP || e.getCode() == KeyCode.Z)    up    = true;
            if (e.getCode() == KeyCode.DOWN || e.getCode() == KeyCode.S)  down  = true;

            if (e.getCode() == KeyCode.SPACE) {
                if (isShip) {
                    fireProjectile();
                } else {
                    jumping = true;
                    if (jetpackTimer == null) {
                        jetpackTimer = new Timer(true);
                        jetpackTimer.schedule(new JetpackTask(), 500L);
                    }
                }
            }
        });
        scene.setOnKeyReleased(e -> {
            boolean isShip = level.getPlatforms().isEmpty() && level.getEnemies().isEmpty();

            if (e.getCode() == KeyCode.LEFT || e.getCode() == KeyCode.Q)  left  = false;
            if (e.getCode() == KeyCode.RIGHT || e.getCode() == KeyCode.D) right = false;
            if (e.getCode() == KeyCode.UP || e.getCode() == KeyCode.Z)    up    = false;
            if (e.getCode() == KeyCode.DOWN || e.getCode() == KeyCode.S)  down  = false;

            if (e.getCode() == KeyCode.SPACE && !isShip) {
                jumping = false;
                jetpack = false;
                player.setJetpackActive(false);
                if (jetpackTimer != null) {
                    jetpackTimer.cancel();
                    jetpackTimer = null;
                }
            }
        });
    }

    /** Starts the main game loop (~60 FPS). */
    public void startGameLoop() {
        gameLoop = new AnimationTimer() {
            private long lastTime = 0;
            @Override
            public void handle(long now) {
                if (lastTime == 0) { lastTime = now; return; }
                double deltaSec = (now - lastTime) / 1_000_000_000.0;
                update(deltaSec);
                lastTime = now;
            }
        };
        gameLoop.start();
    }

    /** Stops the game loop. */
    public void stopGameLoop() {
        if (gameLoop != null) gameLoop.stop();
    }

    /**
     * Main update:
     * - decrement invincibility,
     * - enter boss fight,
     * - handle player movement or spaceship,
     * - collisions/enemies with lives,
     * - camera & render.
     */
    private void update(double deltaSec) {
        // Invincibility countdown
        if (invincible) {
            invincibleTimer -= deltaSec;
            if (invincibleTimer <= 0) {
                invincible = false;
            }
        }

        boolean isShip = level.getPlatforms().isEmpty() && level.getEnemies().isEmpty();

        // Enter boss fight
        boolean bossAlive = enemies.stream().anyMatch(e -> e instanceof Boss);
        if (!inBossFight && bossAlive &&
            player.getX() + player.getWidth() >= level.getBossZoneStart()) {
            inBossFight = true;
        }

        // Player or spaceship movement
        double dx = 0;
        double speed = player.getSpeed() * 1.5;
        if (left)  { dx -= speed * deltaSec; player.setFacingRight(false); }
        if (right) { dx += speed * deltaSec; player.setFacingRight(true); }

        if (isShip) {
            updateSpaceship(dx, deltaSec);
            updateProjectiles(deltaSec);
            if (!inBossFight) {
                cameraX += SHIP_SCROLL_SPEED * deltaSec;
                cameraX = Math.min(cameraX, level.getLevelWidth() - view.getCanvasWidth());
            }
            constrainPlayerInView();
        } else {
            updatePlatform(dx, deltaSec);
        }

        // Constrain in boss zone
        if (inBossFight) {
            double startX = level.getBossZoneStart();
            double endX   = level.getBossZoneEnd() - player.getWidth();
            if (player.getX() < startX) player.setX(startX);
            if (player.getX() > endX)   player.setX(endX);
        }

        // Next level
        if (player.getX() + player.getWidth() >= level.getLevelWidth()) {
            javafx.application.Platform.runLater(model::nextLevel);
        }

        // Exit boss fight
        if (inBossFight && !bossAlive) {
            inBossFight = false;
        }

        // Handle enemies & collisions
        handleEnemies(deltaSec);

        // Camera & render
        updateCamera(isShip);
        render(isShip);
    }

    /**
     * Met à jour chaque ennemi et gère les collisions :
     * - Le Boss n'est mis à jour (poursuite + saut) que si inBossFight == true.
     * - Les autres ennemis sont toujours mis à jour.
     * - Si le joueur saute sur un ennemi, il le neutralise.
     * - Si le joueur touche latéralement un ennemi et n'est pas invincible, il perd une vie.
     */
    private void handleEnemies(double deltaSec) {
        List<Enemy> toRemove = new ArrayList<>();

        for (Enemy e : enemies) {
            // 1) Mise à jour de l'ennemi
            if (e instanceof Boss) {
                if (inBossFight) {
                    ((Boss) e).update(deltaSec, player);
                }
                // sinon : le boss reste immobile tant que le joueur n'est pas dans sa zone
            } else {
                e.update(deltaSec);
            }

            // 2) Gestion des collisions
            if (player.landsOn(e)) {
                // Le joueur saute sur l'ennemi
                if (e instanceof Boss) {
                    Boss boss = (Boss) e;
                    boss.hit();
                    if (boss.isDead()) {
                        toRemove.add(boss);
                    }
                } else {
                    toRemove.add(e);
                }
                // Rebond du joueur
                player.setVelocityY(-600.0);

            } else if (!invincible && player.intersects(e)) {
                // Collision latérale : perte de vie si pas en invincibilité
                loseLife();
            }
        }

        // 3) Suppression des ennemis neutralisés
        enemies.removeAll(toRemove);
    }

    /** Decrements a life, triggers invincibility or game-over reset. */
    private void loseLife() {
        lives--;
        invincible = true;
        invincibleTimer = INVINCIBLE_DURATION;
        updateLivesDisplay();

        if (lives == 0) {
            // Game over for this level: reset lives and respawn
            lives = MAX_LIVES;
            updateLivesDisplay();
            resetPlayerPosition();
        }
        // else: remain in place, just invincible
    }

    /** Refreshes the UI display of lives (except in spaceship). */
    private void updateLivesDisplay() {
        // TODO: update your Label or heart icons, e.g.:
        // livesLabel.setText("Lives: " + lives);
    }

    /** Ensures the spaceship-view player stays on screen. */
    private void constrainPlayerInView() {
        double minX = cameraX;
        double maxX = cameraX + view.getCanvasWidth() - player.getWidth();
        if (player.getX() < minX) player.setX(minX);
        if (player.getX() > maxX) player.setX(maxX);
    }

    /** Spaceship free movement. */
    private void updateSpaceship(double dx, double deltaSec) {
        double dy = 0;
        if (up)   dy -= player.getSpeed() * 1.5 * deltaSec;
        if (down) dy += player.getSpeed() * 1.5 * deltaSec;
        player.move(dx, dy);
    }

    /**
     * Déplacement en mode plateforme :
     * 1) collision horizontale « mur »
     * 2) gravité / saut / jetpack
     * 3) collision verticale « sol/plafond » + fragilePlatform
     */
    private void updatePlatform(double dx, double deltaSec) {
        // Réinitialise le flag walking si pas de déplacement horizontal
        if (dx == 0) {
            player.stopWalking();
        }

        // 1) collision horizontale
        if (dx != 0) {
            // Déplace en X et conserve walking = true
            player.move(dx, 0);

            // Si intersection, colle le joueur contre le mur
            for (Platform p : platforms) {
                if (player.intersects(p)) {
                    if (dx > 0) {
                        // collision à droite
                        player.setX(p.getX() - player.getWidth());
                    } else {
                        // collision à gauche
                        player.setX(p.getX() + p.getWidth());
                    }
                }
            }
        }

        // 2) gravité / saut / jetpack
        if (jumping && player.canJump() && !jetpack) {
            player.setVelocityY(-603.0);
            player.setOnGround(false);
            player.incrementJumps();
            jumping = false;
        }
        if (jetpack && player.isJetpackActive()) {
            // ascension continue tant que le jetpack est actif
            player.setVelocityY(-300.0);
        } else {
            // sinon on applique la gravité
            player.setVelocityY(player.velocityY + GRAVITY * deltaSec);
        }

        // 3) collision verticale
        double oldY = player.getY();
        // on modifie Y directement pour ne pas écraser walking
        player.setY(oldY + player.velocityY * deltaSec);

        // appel de votre handler d'atterrissage + fragilePlatform
        handlePlatformCollisions(oldY);

        // chute sous le niveau → perte de vie
        if (player.getY() > level.getLevelHeight()) {
            loseLife();
        }
    }



    /** Handles collisions with platforms (including fragile). */
    private void handlePlatformCollisions(double oldY) {
        for (Platform p : platforms) {
            if (p instanceof src.model.game.platforms.FragilePlatform) {
                ((src.model.game.platforms.FragilePlatform)p).resetStep(player);
            }
        }
        for (Platform p : platforms) {
            double top    = p.getY();
            double botNow = player.getY() + player.getHeight();
            double botOld = oldY + player.getHeight();
            if (player.intersects(p) && player.velocityY > 0 && botOld <= top) {
                player.setY(top - player.getHeight());
                player.velocityY = 0;
                player.setOnGround(true);
                player.resetJumps();
                if (p instanceof src.model.game.platforms.FragilePlatform) {
                    var fp = (src.model.game.platforms.FragilePlatform)p;
                    if (!fp.isBroken()) fp.step(player);
                }
            }
        }
        platforms.removeIf(p ->
            p instanceof src.model.game.platforms.FragilePlatform
            && ((src.model.game.platforms.FragilePlatform)p).isBroken()
        );
    }

    /** Updates projectiles: movement and enemy collisions. */
    private void updateProjectiles(double deltaSec) {
        var pit = projectiles.iterator();
        while (pit.hasNext()) {
            Projectile pr = pit.next();
            pr.update(deltaSec);
            if (pr.isOutOfBounds(level.getLevelWidth())) {
                pit.remove();
                continue;
            }
            var eit = enemies.iterator();
            while (eit.hasNext()) {
                Enemy e = eit.next();
                if (pr.intersects(e)) {
                    eit.remove();
                    pit.remove();
                    break;
                }
            }
        }
    }

    /** Fires a projectile in spaceship mode. */
    private void fireProjectile() {
        double offsetX = player.isFacingRight() ? player.getWidth() : -10;
        double px      = player.getX() + offsetX;
        double py      = player.getY() + player.getHeight()/2.0;
        projectiles.add(new Projectile(px, py, player.isFacingRight()));
    }

    /** Updates the camera position for platform/boss/ship modes. */
    private void updateCamera(boolean isShip) {
        double cw     = view.getCanvasWidth();
        double ch     = view.getCanvasHeight();
        double levelW = level.getLevelWidth();
        double levelH = level.getLevelHeight();

        // X-axis
        if (inBossFight) {
            double centerX = (level.getBossZoneStart() + level.getBossZoneEnd())/2.0;
            cameraX = centerX - cw/2.0;
        } else if (!isShip) {
            double targetX = player.getX() - cw/2.0;
            cameraX += 0.1 * (targetX - cameraX);
        }
        cameraX = Math.max(0, Math.min(cameraX, levelW - cw));

        // Y-axis
        if (isShip) {
            cameraY = 0;
        } else if (inBossFight) {
            Boss boss = enemies.stream()
                               .filter(e -> e instanceof Boss)
                               .map(e -> (Boss)e)
                               .findFirst()
                               .orElse(null);
            if (boss != null) {
                double centerY = boss.getY() + boss.getHeight()/2.0;
                cameraY = centerY - ch/2.0;
            } else {
                cameraY = (levelH - ch)/2.0;
            }
        } else {
            double targetY = player.getY() - ch/2.0;
            cameraY += 0.1 * (targetY - cameraY);
        }
        if (levelH <= ch) {
            cameraY = levelH - ch;
        }
        double minY = Math.min(0, levelH - ch);
        double maxY = Math.max(0, levelH - ch);
        cameraY = Math.max(minY, Math.min(cameraY, maxY));

        view.cameraXProperty().set(cameraX);
        view.cameraYProperty().set(cameraY);
    }

    /** Renders all game elements via GameView. */
    private void render(boolean isShip) {
        List<Image>     decoImgs = new ArrayList<>();
        List<Double[]>  posDeco  = new ArrayList<>();
        for (Decoration d : decorations) {
            decoImgs.add(d.getTexture());
            posDeco.add(new Double[]{d.getX(), d.getY(), d.getWidth(), d.getHeight()});
        }

        List<Image>     platImgs = new ArrayList<>();
        List<Double[]>  posPl    = new ArrayList<>();
        for (Platform p : platforms) {
            platImgs.add(p.getTexture());
            posPl.add(new Double[]{p.getX(), p.getY(), p.getWidth(), p.getHeight()});
        }

        List<Double[]> posProj = new ArrayList<>();
        for (Projectile pr : projectiles) {
            posProj.add(new Double[]{pr.getX(), pr.getY(), pr.getWidth(), pr.getHeight()});
        }

        boolean isJumping = !player.onGround;
        view.draw(
            level.getBackgroundImage(),
            player.getX(), player.getY(),
            player.getWidth(), player.getHeight(),
            player.isWalking(), player.isFacingRight(),
            isJumping,
            isShip,
            decoImgs, posDeco,
            platImgs, posPl,
            enemies,
            posProj
        );
    }

    /** Respawns the player at the start position. */
    private void resetPlayerPosition() {
        player.setX(initialPlayerX);
        player.setY(initialPlayerY);
        player.velocityY = 0;
        player.setOnGround(true);
        player.resetJumps();
        player.setJetpackActive(false);
        if (jetpackTimer != null) {
            jetpackTimer.cancel();
            jetpackTimer = null;
        }
    }

    /** Resets only the player's state flags. */
    public void resetPlayerState() {
        left = right = up = down = jumping = jetpack = false;
        player.setJetpackActive(false);
        player.resetJumps();
        player.setVelocityY(0);
        player.setOnGround(true);
        if (jetpackTimer != null) {
            jetpackTimer.cancel();
            jetpackTimer = null;
        }
    }

    /** Activates the jetpack after 500ms of holding SPACE. */
    private class JetpackTask extends TimerTask {
        @Override
        public void run() {
            jetpack = true;
            player.setJetpackActive(true);
        }
    }
}
fin fichier ./src/controller/game/GameController.java





début fichier ./src/controller/MainMenuController.java
package src.controller;

import java.util.Locale;

import javafx.stage.Stage;
import src.common.ResourceManager;
import src.controller.editor.GameEditorController;
import src.controller.game.GameController;
import src.view.MainMenuView;

public class MainMenuController {
    MainMenuView view;
    Stage stage;

    public MainMenuController(Stage primaryStage){
        this.stage = primaryStage;
        this.view = new MainMenuView(this, primaryStage);
    }

    public void startGame(Stage primaryStage){
        new GameController(primaryStage);
    }


    public void startEditor(Stage primaryStage){
        new GameEditorController(primaryStage);
    }


    public void handleLanguageChange(String selected){
            switch (selected) {
                case "Français":
                    ResourceManager.setLocale(Locale.FRENCH);
                    this.view = new MainMenuView(this, this.stage);
                    break;
                case "English":
                default:
                    ResourceManager.setLocale(Locale.ENGLISH);
                    break;
            }
            this.view = new MainMenuView(this, this.stage);
    }


    public void handleResolutionChange(String selectedResolution){
        if(selectedResolution.equals("1920x1080")){
            ResourceManager.resolutionWidth = 1920;
            ResourceManager.resolutionHeight = 1080;
        }else if(selectedResolution.equals("1280x720")){
            ResourceManager.resolutionWidth = 1280;
            ResourceManager.resolutionHeight = 720;
        }

        this.view = new MainMenuView(this, this.stage);
    } 
}
fin fichier ./src/controller/MainMenuController.java





début fichier ./src/Main.java
package src;

import java.util.Locale;

import javafx.application.Application;
import javafx.stage.Stage;
import src.common.ResourceManager;
import src.controller.MainMenuController;



public class Main extends Application {
    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        ResourceManager.setLocale(Locale.FRENCH);
        new MainMenuController(primaryStage);

        primaryStage.setTitle("Steampunk Adventure");
        primaryStage.show();
    }
}fin fichier ./src/Main.java





début fichier ./src/model/editor/GameEditorModel.java
package src.model.editor;


import javafx.scene.image.Image;
import javafx.scene.paint.Color;
import src.common.JsonReader;
import src.common.ResourceManager;
import src.controller.editor.GameEditorController;
import src.model.game.Decoration;
import src.model.game.Enemy;
import src.model.game.Level;
import src.model.game.LevelObject;
import src.model.game.Platform;
import src.model.game.platforms.SpawnPoint;

import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeSupport;
import java.io.File;

import javax.sound.sampled.LineListener;

import org.json.JSONObject;


public class GameEditorModel{
    private PropertyChangeSupport support;
    private final GameEditorController controller;
    private String levelName;
    private Level level;
    private String selectedLevelObjectName;
    private LevelObject clickSelectedLevelObject;


    public GameEditorModel(GameEditorController controller){
        this.support = new PropertyChangeSupport(this);
        this.controller = controller;
        this.levelName = null;
        this.level = null;
        this.selectedLevelObjectName = null;
        this.clickSelectedLevelObject = null;
    }

    public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {
        support.addPropertyChangeListener(propertyName, listener);
    }


    public void setLevelName(String levelName){
        String oldValue = this.levelName;
        this.levelName = levelName;
        this.support.firePropertyChange("changeLevelName", oldValue, levelName);
    }
    
    public String getSelectedLevelObjectName(){return this.selectedLevelObjectName;}
    public void setSelectedLevelObjectName(String name){
        String oldName = this.selectedLevelObjectName;
        this.selectedLevelObjectName = name;
        this.support.firePropertyChange("changeSelectedLevelObjectName", oldName, this.selectedLevelObjectName);
    }
    public void setClickSelectedLevelObject(LevelObject levelObject){this.clickSelectedLevelObject = levelObject;}
    public LevelObject getClickSelectedLevelObject(){return this.clickSelectedLevelObject;}
    
    public void setSpawnPoint(double x, double y){
        this.level.setSpawnPoint(new SpawnPoint(x, y, selectedLevelObjectName));
        this.support.firePropertyChange("changeLevelData", null, this.level);
    }

    public void setLevelBackground(Image bg){
        this.level.setBackgroundImage(bg);
        this.support.firePropertyChange("changeLevelData", null, this.level);
    }
    public Level getLevel(){return this.level;}
    public String getLevelName(){return this.levelName;}


    public void addPlatform(double x, double y){
        this.level.addPlatform(x, y, selectedLevelObjectName);
        this.support.firePropertyChange("changeLevelData", null, this.level);
    }
    
    public void removeLevelObject(LevelObject levelObject){
        if(levelObject instanceof Platform){
            if(levelObject instanceof SpawnPoint){
                this.level.setSpawnPoint(null);
            }else{
                this.level.removePlatform((Platform)levelObject);
            }
        }else if(levelObject instanceof Decoration){
            this.level.removeDecoration((Decoration)levelObject);
        }else if(levelObject instanceof Enemy){
            this.level.removeEnemy((Enemy)levelObject);
        }else{
            throw new IllegalStateException("Level object has not the right type");
        }

        this.support.firePropertyChange("changeLevelData", null, this.level);
    }

    //Booléen foreground pour savoir si on ajoute la décoration au premier au à l'arrière plan
    public void addDecoration(double x, double y, boolean foreground){
        if(foreground){
            this.level.addDecoration(x, y, selectedLevelObjectName);
        }else{
            this.level.addDecoration(x, y, selectedLevelObjectName);
        }
        this.support.firePropertyChange("changeLevelData", null, this.level);
    }

    public void addEnemy(double x, double y, double leftBound, double rightBound, double speed){
        this.level.addEnemy(x, y, speed, leftBound, rightBound, this.selectedLevelObjectName);
        this.support.firePropertyChange("changeLevelData", null, this.level);
    }
    
    public boolean saveLevel(boolean overwrite){
        JSONObject levelJSON = level.toJSONObject();

        return JsonReader.saveJsonObject(levelJSON, ResourceManager.LEVELS_FOLDER + levelName + ".json", overwrite);
    }

    public void deleteLevel(String levelName){
        File levelFile = new File(ResourceManager.LEVELS_FOLDER + levelName + ".json");

        if (levelFile.exists()) levelFile.delete();
    }


    //Pour charger un niveau déjà existant
    public void loadLevel(String levelName){
        this.level = new Level(null, levelName);
        this.setLevelName(levelName);
        this.support.firePropertyChange("initLevel", null, this.level);
    }

    //Pour initialiser un nouveau niveau
    public void initLevel(String levelName, double levelWidth, double levelHeight){
        Level lastLevel = this.level;
        this.setLevelName(levelName);
        this.level = new Level(levelWidth, levelHeight);
        this.support.firePropertyChange("initLevel", lastLevel, this.level);
    }





    public LevelObject getLevelObjectAt(double x, double y){
        for (LevelObject levelObject : this.level.getLevelObjects()) {
            if(levelObject.getX() == x && levelObject.getY() == y){
                return levelObject;
            }
        } 
        return null;
    }

}
fin fichier ./src/model/editor/GameEditorModel.java





début fichier ./src/model/game/Boss.java
package src.model.game;

public class Boss extends Enemy {
    // ——— Physique du saut ———
    private double velocityY     = 0.0;
    private static final double GRAVITY    = 1800.0;
    private static final double JUMP_SPEED = 800.0;
    private final double groundY;
    private boolean onGround;

    // ——— Cooldown entre deux sauts ———
    private double jumpTimer = 0.0;
    private static final double JUMP_COOLDOWN = 2.5; // en secondes

    // ——— Gestion des hits / disparition ———
    private int hits         = 0;
    private static final int MAX_HITS  = 3;
    private double hitTimer  = 0.0;

    public Boss(double x, double y, double speed, double leftBound, double rightBound, String name) {
        super(x, y, speed, leftBound, rightBound, name);
        this.groundY   = y;
        this.onGround  = true;
        this.jumpTimer = JUMP_COOLDOWN; // prêt à sauter immédiatement
    }

    /**
     * Met à jour le boss : poursuite horizontale et saut vers le joueur.
     *
     * @param deltaSec Temps écoulé depuis la dernière frame (en secondes)
     * @param player   Référence au joueur, pour cibler ses coordonnées
     */
    public void update(double deltaSec, Player player) {
        // 1) Poursuite horizontale (vers le joueur, dans sa zone)
        double move = getSpeed() * deltaSec;
        if (player.getX() > getX() && getX() + move <= getRightBound()) {
            setX(getX() + move);
        } else if (player.getX() < getX() && getX() - move >= getLeftBound()) {
            setX(getX() - move);
        }

        // 2) Gestion du saut
        jumpTimer += deltaSec;
        if (onGround && jumpTimer >= JUMP_COOLDOWN) {
            velocityY = -JUMP_SPEED;
            onGround  = false;
            jumpTimer = 0.0;
        }

        // 3) Gravité + intégration Y
        velocityY += GRAVITY * deltaSec;
        setY(getY() + velocityY * deltaSec);

        // 4) Atterrissage
        if (getY() >= groundY) {
            setY(groundY);
            velocityY = 0.0;
            onGround  = true;
        }

        // 5) Flash rouge après hit
        if (hitTimer > 0) {
            hitTimer = Math.max(0, hitTimer - deltaSec);
        }
    }

    /** Appelé quand le joueur saute dessus. */
    public void hit() {
        hits++;
        hitTimer = 0.2;
    }

    /** True si on est en plein flash rouge. */
    public boolean isHit() {
        return hitTimer > 0;
    }

    /** True si le boss doit disparaître. */
    public boolean isDead() {
        return hits >= MAX_HITS;
    }
}
fin fichier ./src/model/game/Boss.java





début fichier ./src/model/game/Decoration.java
package src.model.game;

import javafx.scene.image.Image;
import src.common.JsonReader;
import src.common.ResourceManager;

import org.json.JSONObject;


public class Decoration extends LevelObject{
    public Decoration(double x, double y, String name) {
        super(x, y, name, ResourceManager.DECORATIONS_JSON, ResourceManager.DECORATIONS_FOLDER);
    }
}
fin fichier ./src/model/game/Decoration.java





début fichier ./src/model/game/Enemy.java
package src.model.game;

import src.common.JsonReader;
import src.common.ResourceManager;

import org.json.JSONObject;

import javafx.scene.image.Image;


public class Enemy extends LevelObject{
    private double speed;
    private double leftBound, rightBound;
    private boolean movingRight = true;


    public Enemy(double x, double y, double speed, double leftBound, double rightBound, String name) {
        super(x, y, name, ResourceManager.ENEMIES_JSON, ResourceManager.ENEMIES_FOLDER);
        this.speed = speed;
        this.leftBound = leftBound;
        this.rightBound = rightBound;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    public Image getTexture() {
        return this.texture;
    }

    /** @param deltaSec  temps écoulé (s) */
    /**
     * @param deltaSec  temps écoulé (s) depuis la dernière frame
     */
    public void update(double deltaSec) {
        double move = speed * deltaSec;
        if (movingRight) {
            x += move;
            if (x >= rightBound) movingRight = false;
        } else {
            x -= move;
            if (x <= leftBound) movingRight = true;
        }
    }

    @Override
    public JSONObject toJSONObject(){
        JSONObject enemyJSON = super.toJSONObject();
        enemyJSON.put("patrolStart", this.leftBound);
        enemyJSON.put("patrolEnd", this.rightBound);
        enemyJSON.put("speed", this.speed);

        return enemyJSON;
    }

    // --- Nouveaux accesseurs pour permettre à Boss de changer y ---
    /** Position horizontale de l'ennemi. */
    public void setX(double x) {
        this.x = x;
    }

    /** Position verticale de l'ennemi. */
    public void setY(double y) {
        this.y = y;
    }

    public double getSpeed() { 
        return speed; 
    }
    public double getLeftBound() { 
        return leftBound; 
    }
    public double getRightBound() { 
        return rightBound; 
    }
}
fin fichier ./src/model/game/Enemy.java





début fichier ./src/model/game/GameModel.java
// src/Game.java
package src.model.game;

import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;
import src.common.ResourceManager;
import src.controller.game.GameController;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

public class GameModel{
    private static final int WIDTH  = 800;
    private static final int HEIGHT = 600;

    private Stage primaryStage;
    private Scene scene;
    private Pane root;
    private Canvas canvas;
    private Player player;
    private GameController controller;

    private List<Function<Player, Level>> levelSuppliers;
    private int currentLevelIndex = 0;


    public GameModel(GameController controller){
        this.controller = controller;
        this.player = new Player(100, 500);


        // Liste des noms de niveaux JSON
        List<String> levelNames = List.of("level1", "level2", "level3", "level4", "level5", "horlogerie");
        levelSuppliers = new ArrayList<>();

        // Instancie Level(player, name) pour chaque JSON
        for (String name : levelNames) {
            levelSuppliers.add(p -> new Level(p, name));
        }
        // Insère le niveau vaisseau (spaceship.json) après le premier
        levelSuppliers.add(1, p -> new Level(p, "spaceship"));

        loadCurrentLevel();
    }

    public GameModel(GameController controller, String levelName){
        this.controller = controller;
        this.player = new Player(100, 500);


        // Liste des noms de niveaux JSON
        List<String> levelNames = List.of(levelName);
        levelSuppliers = new ArrayList<>();

        // Instancie Level(player, name) pour chaque JSON
        for (String name : levelNames) {
            levelSuppliers.add(p -> new Level(p, name));
        }
        loadCurrentLevel();
    }


    private void loadCurrentLevel() {
        Level lvl = levelSuppliers.get(currentLevelIndex).apply(player);

        if (currentLevelIndex > 0) {
            controller.stopGameLoop();
        }

        controller.setPlayer(player);
        controller.setLevel(lvl);


        controller.handleInput();
        controller.startGameLoop();
    }

    public void nextLevel() {
        controller.resetPlayerState();
        player.setX(100);
        player.setY(500);

        if (currentLevelIndex < levelSuppliers.size() - 1) {
            currentLevelIndex++;
            loadCurrentLevel();
        } else {
            System.out.println(ResourceManager.getString("GameModel_win_message"));
            controller.stopGameLoop();
        }
    }
}
fin fichier ./src/model/game/GameModel.java





début fichier ./src/model/game/Level.java
// src/levels/Level.java
package src.model.game;

import javafx.scene.image.Image;
import src.common.JsonReader;
import src.common.ResourceManager;
import src.model.game.Decoration;
import src.model.game.Enemy;
import src.model.game.Platform;
import src.model.game.Player;
import src.model.game.platforms.FragilePlatform;
import src.model.game.platforms.SpawnPoint;
import src.controller.editor.GameEditorController.LevelObjectType;

import org.json.JSONArray;
import org.json.JSONObject;

import java.util.List;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URI;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;

public class Level {
    // ——— Champs principaux ———
    protected List<Platform>   platforms;
    protected List<Enemy>      enemies;
    protected List<Decoration> decorations;
    protected Player           player;
    protected Image            backgroundImage;
    protected double           levelWidth;
    protected double           levelHeight;
    protected SpawnPoint spawnPoint;

    // ——— Zone de boss (optionnelle) ———
    private double bossZoneStart = Double.NEGATIVE_INFINITY;
    private double bossZoneEnd   = Double.POSITIVE_INFINITY;

    //Constructeur pour initialiser un level pour l'editeur de niveau
    public Level(double levelWidth, double levelHeight) {
        this.platforms   = new ArrayList<>();
        this.enemies     = new ArrayList<>();
        this.decorations = new ArrayList<>();
        this.levelWidth = levelWidth;
        this.levelHeight = levelHeight;
        this.spawnPoint = null;
    }

    /** Constructeur JSON : charge "levels/{levelName}.json". */
    public Level(Player player, String levelName) {
        this.player      = player;
        this.platforms   = new ArrayList<>();
        this.enemies     = new ArrayList<>();
        this.decorations = new ArrayList<>();
        initialize(levelName);
        if(this.player != null){
            this.player.setX(this.spawnPoint.getX());
            this.player.setY(this.spawnPoint.getY() - this.player.getHeight());
        }
    }

    /** Initialise le niveau depuis le JSON correspondant. */
    protected void initialize(String levelName) {
        JSONObject L = JsonReader.getJsonObjectContent(ResourceManager.LEVELS_FOLDER + levelName + ".json");
        if (L == null) {
            throw new IllegalStateException("Impossible de charger le JSON pour le niveau : " + levelName);
        }

        // 1) Background + dimensions
        if (L.has("backgroundImageFileName")) {this.backgroundImage = new Image("file:" + ResourceManager.BACKGROUNDS_FOLDER + L.getString("backgroundImageFileName"));}
        this.levelWidth  = L.getDouble("levelWidth");
        this.levelHeight = L.getDouble("levelHeight");

        // 2) Plateformes
        JSONArray plats = L.getJSONArray("platforms");
        for (int i = 0; i < plats.length(); i++) {
            JSONObject p = plats.getJSONObject(i);
            String name = p.getString("name");
            double x     = p.getDouble("x");
            double y     = p.getDouble("y");

            JSONObject platformJSON = ResourceManager.PLATFORMS_JSON.getJSONObject(name);
            String typeStr = platformJSON.getString("type");
            LevelObjectType type = LevelObjectType.valueOf(typeStr);
            if(type == LevelObjectType.FRAGILE_PLATFORM){
                platforms.add(new FragilePlatform(x, y, name));
            }else if(type == LevelObjectType.PLATFORM){
                platforms.add(new Platform(x, y, name));
            }else if(type == LevelObjectType.SPAWNPOINT){
                this.spawnPoint = new SpawnPoint(x, y, name);
            }
        }

        // 3) Ennemis + boss
        JSONArray ens = L.getJSONArray("enemies");
        for (int i = 0; i < ens.length(); i++) {
            JSONObject e = ens.getJSONObject(i);
            String name = e.getString("name");
            double x           = e.getDouble("x");
            double y           = e.getDouble("y");
            double speed       = e.getDouble("speed");
            double patrolStart = e.getDouble("patrolStart");
            double patrolEnd   = e.getDouble("patrolEnd");

            JSONObject enemyJSON = ResourceManager.ENEMIES_JSON.getJSONObject(name);
            String typeStr = enemyJSON.getString("type");
            LevelObjectType type = LevelObjectType.valueOf(typeStr);
            if(type == LevelObjectType.BOSS){
                enemies.add(new Boss(x, y, speed, patrolStart, patrolEnd, name));
            }else if(type == LevelObjectType.ENEMY){
                enemies.add(new Enemy(x, y, speed, patrolStart, patrolEnd, name));
            }
        }

        // 4) Décorations (optionnel)
        if (L.has("decorations")) {
            for (Object o : L.getJSONArray("decorations")) {
                JSONObject d = (JSONObject) o;
                double x = d.getDouble("x");
                double y =  d.getDouble("y");
                String name = d.getString("name");

                JSONObject decorationJSON = ResourceManager.DECORATIONS_JSON.getJSONObject(name);
                String typeStr = decorationJSON.getString("type");
                LevelObjectType type = LevelObjectType.valueOf(typeStr);
                if(type == LevelObjectType.DECORATION){
                    decorations.add(new Decoration(x, y, name));
                }
            }
        }

        // 5) Zone de boss (optionnel)
        if (L.has("bossZone")) {
            JSONObject bz = L.getJSONObject("bossZone");
            bossZoneStart = bz.getDouble("startX");
            bossZoneEnd   = bz.getDouble("endX");
        }



        if (L.has("spawnPoint")){
            JSONObject sp = L.getJSONObject("spawnPoint");
            double x = sp.getDouble("x");
            double y =  sp.getDouble("y");
            String name = sp.getString("name");
            this.spawnPoint = new SpawnPoint(x, y, name);
        }else{
            this.spawnPoint = new SpawnPoint(0, 0, "Spawnpoint");
        }
    }

    // ——— Getters ———

    public List<Platform>   getPlatforms()       { return platforms;    }
    public List<Enemy>      getEnemies()         { return enemies;      }
    public List<Decoration> getDecorations()     { return decorations;  }
    public Image            getBackgroundImage() { return backgroundImage; }
    public double           getLevelWidth()      { return levelWidth;   }
    public double           getLevelHeight()     { return levelHeight;  }
    public SpawnPoint getSpawnPoint(){return this.spawnPoint;}
    public List<LevelObject> getLevelObjects() {
        List<LevelObject> levelObjects = new ArrayList<>();
        levelObjects.addAll(this.platforms);
        levelObjects.addAll(this.decorations);
        levelObjects.addAll(this.enemies);
        if(this.spawnPoint != null) levelObjects.add(this.spawnPoint);
        return levelObjects;
    }

    /** Coordonnée X où commence la zone de boss (infinie si non définie). */
    public double getBossZoneStart() { return bossZoneStart; }
    /** Coordonnée X où se termine la zone de boss (infinie si non définie). */
    public double getBossZoneEnd()   { return bossZoneEnd;   }


    // ——————————— Setters ———————————

    public void setBackgroundImage(Image bg) {this.backgroundImage = bg;}
    public void setLevelWidth(double w) {this.levelWidth = w;}
    public void setLevelHeight(double h) {this.levelHeight = h;}
    public void addPlatform(double x, double y, String platformName) {this.platforms.add(new Platform(x, y, platformName));}
    public void addDecoration(double x, double y, String decorationName) {this.decorations.add(new Decoration(x, y, decorationName));}
    public void addEnemy(double x, double y, double speed, double leftBound, double rightBound, String name){this.enemies.add(new Enemy(x, y, speed, leftBound, rightBound, name));}
    public void removePlatform(Platform platform){this.platforms.remove(platform);}
    public void removeDecoration(Decoration decoration){this.decorations.remove(decoration);}
    public void removeEnemy(Enemy enemy){this.enemies.remove(enemy);}
    public void setSpawnPoint(SpawnPoint spawnPoint){this.spawnPoint = spawnPoint;}

    // ——————————— Helpers ———————————

    public JSONObject toJSONObject(){
        JSONObject levelJSON = new JSONObject();

        JSONArray platformsJSON = new JSONArray();
        for (Platform platform : platforms) {   
            platformsJSON.put(platform.toJSONObject());
        }
        levelJSON.put("platforms", platformsJSON);

        JSONArray enemiesJSON = new JSONArray();
        for (Enemy enemy : enemies) {   
            enemiesJSON.put(enemy.toJSONObject());
        }
        levelJSON.put("enemies", enemiesJSON);

        JSONArray decorationsJSON = new JSONArray();
        for (Decoration decoration : decorations) {   
            decorationsJSON.put(decoration.toJSONObject());
        }
        levelJSON.put("decorations", decorationsJSON);


        if(this.backgroundImage == null){
            levelJSON.put("backgroundImageFileName", "default.png");
        }else{
            //On vérifie si le fond de niveau existe déjà dans le dossier des fond
            //S'il existe c'est que le niveau avait déjà chargé le fond via le dossier
            //Sinon c'est qu'il a été choisi par l'utilisateur potentiellement dans un
            //autre dossier, donc il faut le copier dans le dossier des fonds pour 
            //pouvoir sauvegarder le nom dans le json et le recharger plus tard
            String backgroundURL = this.backgroundImage.getUrl();
            String backgroundName = backgroundURL.substring(backgroundURL.lastIndexOf('/') + 1);
            File backgroundFile = new File(ResourceManager.BACKGROUNDS_FOLDER + backgroundName);
            if(!backgroundFile.exists()){
                try (InputStream in = URI.create(backgroundURL).toURL().openStream();
                    OutputStream out = new FileOutputStream(backgroundFile)) {

                    byte[] buffer = new byte[4096];
                    int bytesRead;

                    while ((bytesRead = in.read(buffer)) != -1) {
                        out.write(buffer, 0, bytesRead);
                    }

                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            levelJSON.put("backgroundImageFileName", backgroundName);
        }


        levelJSON.put("levelWidth", this.levelWidth);
        levelJSON.put("levelHeight", this.levelHeight);

        //On ajoute la zone de boss dans le json que si il y a des valeurs spécifique.
        if(this.bossZoneStart != Double.NEGATIVE_INFINITY){
            JSONObject bossZoneJSON = new JSONObject();
            bossZoneJSON.put("startX", this.bossZoneStart);
            bossZoneJSON.put("endX", this.bossZoneEnd);
            levelJSON.put("bossZone", bossZoneJSON);
        }

        if (this.spawnPoint != null){
            JSONObject spawnPointJSON = this.spawnPoint.toJSONObject();
            levelJSON.put("spawnPoint", spawnPointJSON);
        }
        

        return levelJSON;
    }
}
fin fichier ./src/model/game/Level.java





début fichier ./src/model/game/LevelObject.java
package src.model.game;

import javafx.scene.image.Image;
import src.common.ResourceManager;

import java.nio.channels.Pipe.SourceChannel;

import org.json.JSONObject;

public abstract class LevelObject {
    protected double x, y, width, height;
    protected Image texture;
    protected String name;

    protected LevelObject(double x, double y, String name, JSONObject levelObjectsJson, String pathToLevelObjectFolder) {
        this.x = x;
        this.y = y;
        
        JSONObject levelObjectJson = levelObjectsJson.getJSONObject(name);
        this.name = name;
        double scaleFactor;
        if(name == null){
            this.texture = new Image("file:" + ResourceManager.DEFAULT_TEXTURE);
            scaleFactor = 1;
        }else{
            this.texture = new Image("file:" + pathToLevelObjectFolder + levelObjectJson.getString("textureFileName"));
            scaleFactor = levelObjectJson.getDouble("scaleFactor");
        }

        this.width = texture.getWidth() * scaleFactor;
        this.height = texture.getHeight() * scaleFactor;
    }

    public double getX()      { return x; }
    public double getY()      { return y; }
    public double getWidth()  { return width; }
    public double getHeight() { return height; }
    public Image getTexture() { return texture;}
    public String getName() { return name; }

    public JSONObject toJSONObject(){
        JSONObject obj = new JSONObject();
        obj.put("name", this.name);
        obj.put("x", this.x);
        obj.put("y", this.y);
        
        return obj;
    }
}
fin fichier ./src/model/game/LevelObject.java





début fichier ./src/model/game/Platform.java
package src.model.game;

import javafx.scene.image.Image;
import src.common.JsonReader;
import src.common.ResourceManager;

import java.util.ResourceBundle;

import org.json.JSONObject;

public class Platform extends LevelObject{
    public Platform(double x, double y, String name) {
        super(x, y, name, ResourceManager.PLATFORMS_JSON, ResourceManager.PLATFORMS_FOLDER);
    }
}
fin fichier ./src/model/game/Platform.java





début fichier ./src/model/game/platforms/FragilePlatform.java
package src.model.game.platforms;

import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.image.PixelReader;
import javafx.scene.image.PixelWriter;
import javafx.scene.image.WritableImage;
import src.common.ResourceManager;
import src.model.game.Platform;
import src.model.game.Player;
import org.json.JSONObject;

public class FragilePlatform extends Platform {
    private int steps = 0;
    private static final int MAX_STEPS = 2;
    private boolean playerWasOn = false;
    private Image fragileTexture; 

    public FragilePlatform(double x, double y, String name){
        super(x, y, name);

        this.fragileTexture = new Image("file:" + ResourceManager.PLATFORMS_FOLDER + "fragile_overlay.png");


        //Créer une copie modifiable de la texture de base pour pouvoir superposer l'image
        //"fragile" par dessus.
        WritableImage resultImage = new WritableImage((int) this.texture.getWidth(), (int) this.texture.getHeight());
        PixelReader baseReader = this.texture.getPixelReader();
        PixelReader overlayReader = this.fragileTexture.getPixelReader();
        PixelWriter writer = resultImage.getPixelWriter();

        for (int y_ = 0; y_ < this.texture.getHeight(); y_++) {
            for (int x_ = 0; x_ < this.texture.getWidth(); x_++) {
                //Lire les couleurs
                javafx.scene.paint.Color baseColor = baseReader.getColor(x_, y_);
                //On répète l'image "fragile" si l'image de base était plus grande grâce au modulo
                javafx.scene.paint.Color overlayColor = overlayReader.getColor((int)(x_%this.fragileTexture.getWidth()), (int)(y_%this.fragileTexture.getHeight()));

                //Mélanger les couleurs (simple alpha blending)
                double alpha = overlayColor.getOpacity();
                javafx.scene.paint.Color blendedColor = baseColor.interpolate(overlayColor, alpha);

                //Ecrire dans l'image résultante
                writer.setColor(x_, y_, blendedColor);
            }
        }

        this.fragileTexture = resultImage;
    }

    /**
     * Appelée quand le joueur atterrit sur la plateforme.
     * - 1er atterrissage : on passe à la texture fissurée.
     * - 2e atterrissage : la plateforme sera considérée comme « cassée ».
     */
    public void step(Player player) {
        if (!playerWasOn) {
            steps++;
            if (steps == 1) {
                // applique la texture fissurée
                this.texture = this.fragileTexture;
            }
            playerWasOn = true;
        }
    }

    /** Remet playerWasOn à false dès que le joueur n'est plus sur la plateforme. */
    public void resetStep(Player player) {
        if (!player.intersects(this)) {
            playerWasOn = false;
        }
    }

    /** True si la plateforme doit être retirée (après 2 atterrissages). */
    public boolean isBroken() {
        return steps >= MAX_STEPS;
    }
}
fin fichier ./src/model/game/platforms/FragilePlatform.java





début fichier ./src/model/game/platforms/SpawnPoint.java
package src.model.game.platforms;

import src.model.game.Platform;

public class SpawnPoint extends Platform{
    public SpawnPoint(double x, double y, String name){
        super(x,y,name);
    }
}
fin fichier ./src/model/game/platforms/SpawnPoint.java





début fichier ./src/model/game/Player.java
package src.model.game;

import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;

/**
 * Classe Player : gère la position, la vitesse, l'état (walking, jetpack, etc.)
 */
public class Player {
    private DoubleProperty x = new SimpleDoubleProperty();
    private DoubleProperty y = new SimpleDoubleProperty();
    private double width = 50;
    private double height = 50;
    public double velocityY = 0;
    public boolean onGround = false;
    private int jumps = 0;
    private static final int MAX_JUMPS = 2;
    private double speed = 180.0;
    private boolean jetpackActive = false;
    private boolean walking = false;

    // Propriété indiquant la direction : true = face à droite, false = face à gauche
    private boolean facingRight = true;

    public Player(double x, double y) {
        this.x.set(x);
        this.y.set(y);
    }

    public double getX() { return x.get(); }
    public void setX(double x) { this.x.set(x); }
    public DoubleProperty xProperty() { return x; }

    public double getY() { return y.get(); }
    public void setY(double y) { this.y.set(y); }
    public DoubleProperty yProperty() { return y; }

    public double getWidth() { return width; }
    public double getHeight() { return height; }

    public void move(double dx, double dy) {
        setX(getX() + dx);
        setY(getY() + dy);
        walking = (dx != 0);
    }

    public boolean isWalking() { return walking; }
    public void stopWalking() { walking = false; }

    public boolean intersects(Platform platform) {
        /*System.out.println("[DEBUG] Player intersects() -> "
            + "Player: x=" + getX() + ", y=" + getY()
            + ", w=" + getWidth() + ", h=" + getHeight()
            + " | Platform: x=" + platform.getX()
            + ", y=" + platform.getY()
            + ", w=" + platform.getWidth()
            + ", h=" + platform.getHeight());*/
        return getX() < platform.getX() + platform.getWidth()
            && getX() + getWidth() > platform.getX()
            && getY() < platform.getY() + platform.getHeight()
            && getY() + getHeight() > platform.getY();
    }

    public boolean intersects(Enemy enemy) {
        return getX() < enemy.getX() + enemy.getWidth()
            && getX() + getWidth() > enemy.getX()
            && getY() < enemy.getY() + enemy.getHeight()
            && getY() + getHeight() > enemy.getY();
    }

    public boolean landsOn(Enemy enemy) {
        return getX() < enemy.getX() + enemy.getWidth()
            && getX() + getWidth() > enemy.getX()
            && getY() + getHeight() >= enemy.getY()
            && getY() + getHeight() <= enemy.getY() + enemy.getHeight() / 2
            && velocityY > 0;
    }

    public int getJumps() { return jumps; }
    public void incrementJumps() { jumps++; }
    public void resetJumps() { jumps = 0; }
    public boolean canJump() { return jumps < MAX_JUMPS; }
    public double getSpeed() { return speed; }
    public void setSpeed(double speed) { this.speed = speed; }
    public boolean isJetpackActive() { return jetpackActive; }
    public void setJetpackActive(boolean jetpackActive) { this.jetpackActive = jetpackActive; }
    public void setVelocityY(double velocityY) { this.velocityY = velocityY; }
    public void setOnGround(boolean onGround) { this.onGround = onGround; }

    // Accesseurs pour la direction du joueur
    public boolean isFacingRight() {
        return facingRight;
    }

    public void setFacingRight(boolean facingRight) {
        this.facingRight = facingRight;
    }
}
fin fichier ./src/model/game/Player.java





début fichier ./src/model/game/Projectile.java
package src.model.game;

/**
 * Un projectile tiré par le vaisseau.
 */
public class Projectile {
    private double x, y;
    private static final double WIDTH  = 10;
    private static final double HEIGHT = 4;
    private static final double SPEED  = 360.0;
    private final boolean toRight;

    public Projectile(double x, double y, boolean toRight) {
        this.x       = x;
        this.y       = y;
        this.toRight = toRight;
    }

    /** Avance le projectile d’une frame. */
    /** @param deltaSec  temps écoulé (s) */
    public void update(double deltaSec) {
        x += (toRight ? 1 : -1) * SPEED * deltaSec;
    }


    /** Indique si le projectile est hors limites du niveau. */
    public boolean isOutOfBounds(double levelWidth) {
        return x + WIDTH < 0 || x > levelWidth;
    }

    /** Collision AABB basique avec un ennemi. */
    public boolean intersects(Enemy e) {
        return x < e.getX() + e.getWidth()
            && x + WIDTH  > e.getX()
            && y < e.getY() + e.getHeight()
            && y + HEIGHT > e.getY();
    }

    // Getters
    public double getX()      { return x; }
    public double getY()      { return y; }
    public double getWidth()  { return WIDTH; }
    public double getHeight() { return HEIGHT; }
}
fin fichier ./src/model/game/Projectile.java





début fichier ./src/test/SpaceshipTest.java
package test;

import javafx.animation.AnimationTimer;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import src.common.ResourceManager;
import javafx.scene.input.KeyCode;

/**
 * Exemple minimal : un "vaisseau" (cercle) qui se déplace
 * librement avec les flèches. Aucune gravité, aucune collision.
 */
public class SpaceshipTest extends Application {

    private double x = 100;   // Position initiale du "vaisseau"
    private double y = 300;
    private double speed = 3; // Vitesse de déplacement

    private boolean up, down, left, right;

    @Override
    public void start(Stage primaryStage) {
        Canvas canvas = new Canvas(ResourceManager.resolutionWidth, ResourceManager.resolutionHeight);
        GraphicsContext gc = canvas.getGraphicsContext2D();

        StackPane root = new StackPane(canvas);
        Scene scene = new Scene(root, ResourceManager.resolutionWidth, ResourceManager.resolutionHeight);

        // Gestion des touches
        scene.setOnKeyPressed(e -> {
            if (e.getCode() == KeyCode.UP)    up    = true;
            if (e.getCode() == KeyCode.DOWN)  down  = true;
            if (e.getCode() == KeyCode.LEFT)  left  = true;
            if (e.getCode() == KeyCode.RIGHT) right = true;
        });
        scene.setOnKeyReleased(e -> {
            if (e.getCode() == KeyCode.UP)    up    = false;
            if (e.getCode() == KeyCode.DOWN)  down  = false;
            if (e.getCode() == KeyCode.LEFT)  left  = false;
            if (e.getCode() == KeyCode.RIGHT) right = false;
        });

        primaryStage.setTitle(ResourceManager.getString("SpaceshipTest_title"));
        primaryStage.setScene(scene);
        primaryStage.show();

        // Boucle de jeu : ~60 fps
        AnimationTimer timer = new AnimationTimer() {
            @Override
            public void handle(long now) {
                update();
                draw(gc);
            }
        };
        timer.start();
    }

    /**
     * Met à jour la position du "vaisseau".
     */
    private void update() {
        if (up)    y -= speed;
        if (down)  y += speed;
        if (left)  x -= speed;
        if (right) x += speed;
    }

    /**
     * Dessine la scène : efface l'écran et dessine un cercle.
     */
    private void draw(GraphicsContext gc) {
        gc.clearRect(0, 0, 800, 600);

        gc.setFill(Color.BLACK);
        gc.fillRect(0, 0, 800, 600);

        gc.setFill(Color.WHITE);
        gc.setFont(Font.font(18));
        gc.fillText(ResourceManager.getString("SpaceshipTest_info_key")+"\nX=" + x + ", Y=" + y, 20, 30);

        // Dessine un cercle comme "vaisseau"
        gc.setFill(Color.YELLOW);
        gc.fillOval(x, y, 40, 40);
    }

    public static void main(String[] args) {
        launch(args);
    }
}
fin fichier ./src/test/SpaceshipTest.java





début fichier ./src/view/editor/EditorLevelObjectSelectorView.java
package src.view.editor;

import java.util.Set;

import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.ListView;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.VBox;
import src.common.JsonReader;
import src.common.ResourceManager;
import src.controller.editor.EditorLevelObjectSelectorController;
import src.controller.editor.GameEditorController.LevelObjectType;
import org.json.JSONObject;

public class EditorLevelObjectSelectorView {
    private EditorLevelObjectSelectorController controller;
    private VBox region;

    public EditorLevelObjectSelectorView(EditorLevelObjectSelectorController controller){
        this.controller = controller;
        this.region = new VBox();
        this.region.getStyleClass().add("main-region");

        initializeLevelObjectSelector();
    }


    public VBox getRegion(){return this.region;}


    public void initializeLevelObjectSelector(){
        ListView<LevelObjectSelectorItem> levelObjectSelector = new ListView<>();
        //Gestion de la sélection
        levelObjectSelector.getSelectionModel().selectedItemProperty().addListener((obs, oldValue, newValue) -> {
            if(newValue == null){
                this.controller.handleSelectedLevelObjectChange(null);
            }else{
                this.controller.handleSelectedLevelObjectChange(newValue.getLevelObjectNameLabel().getText());
            }
        });

        //Chargement des plateformes dans le ListView
        JSONObject platformsObjects = JsonReader.getJsonObjectContent(ResourceManager.RESOURCE_FOLDER + "platforms.json");
        levelObjectSelector.getItems().add(new LevelObjectSelectorItem(ResourceManager.getString("EditorLevelObjectSelectorView_separator_platforms")));
        Set<String> keys = platformsObjects.keySet();
        for (String name : keys) {
            JSONObject platform = platformsObjects.getJSONObject(name);
            String typeStr = platform.getString("type");
            LevelObjectType type = LevelObjectType.valueOf(typeStr);
            LevelObjectSelectorItem temp = new LevelObjectSelectorItem(name, platformsObjects, type);
            levelObjectSelector.getItems().add(temp);
        }

        //Chargement des decorations dans le ListView
        JSONObject decorationsObjects = JsonReader.getJsonObjectContent(ResourceManager.RESOURCE_FOLDER + "decorations.json");
        levelObjectSelector.getItems().add(new LevelObjectSelectorItem(ResourceManager.getString("EditorLevelObjectSelectorView_separator_decorations")));
        keys.clear();
        keys = decorationsObjects.keySet();
        for (String name : keys) {
            JSONObject decoration = decorationsObjects.getJSONObject(name);
            String typeStr = decoration.getString("type");
            LevelObjectType type = LevelObjectType.valueOf(typeStr);
            LevelObjectSelectorItem temp = new LevelObjectSelectorItem(name, decorationsObjects, type);
            levelObjectSelector.getItems().add(temp);
        }
        
        //Chargement des ennemis dans le ListView
        JSONObject enemiesObjects = JsonReader.getJsonObjectContent(ResourceManager.RESOURCE_FOLDER + "enemies.json");
        levelObjectSelector.getItems().add(new LevelObjectSelectorItem(ResourceManager.getString("EditorLevelObjectSelectorView_separator_enemies")));
        keys.clear();
        keys = enemiesObjects.keySet();
        for (String name : keys) {
            JSONObject enemy = enemiesObjects.getJSONObject(name);
            String typeStr = enemy.getString("type");
            LevelObjectType type = LevelObjectType.valueOf(typeStr);
            LevelObjectSelectorItem temp = new LevelObjectSelectorItem(name, enemiesObjects, type);
            levelObjectSelector.getItems().add(temp);
        }


        levelObjectSelector.setPrefWidth(200);

        Button retractButton = new Button("<");
        //Gestion de la rétraction du sélecteur de plateformes
        retractButton.setOnAction(e -> {
            if (levelObjectSelector.isVisible()) {
                this.region.setPrefWidth(retractButton.getWidth());
                levelObjectSelector.setVisible(false);
                retractButton.setText(">");
            } else{
                this.region.setPrefWidth(levelObjectSelector.getPrefWidth());
                levelObjectSelector.setVisible(true);
                retractButton.setText("<");
            }
        });
        Button unselectButton = new Button(ResourceManager.getString("unselect_button"));
        //Gestion de la déselection de plateforme dans le sélecteur
        unselectButton.setOnAction(e -> {levelObjectSelector.getSelectionModel().clearSelection();});
        this.region.getChildren().addAll(retractButton, levelObjectSelector, unselectButton);
    }
}


class LevelObjectSelectorItem extends VBox{
    private Label levelObjectNameLabel;
    private Image texture;
    private double textureScaleFactor;
    private LevelObjectType levelObjectType;


    //Pour faire un séparateur
    public LevelObjectSelectorItem(String levelObjectName){
        super();

        this.levelObjectNameLabel = new Label("    "+ levelObjectName+ "    ");
        this.levelObjectNameLabel.getStyleClass().add("sp-separator");
        this.getChildren().add(this.levelObjectNameLabel);
        this.texture = null;
    }

    //Pour faire un élément 
    public LevelObjectSelectorItem(String levelObjectName, JSONObject objects, LevelObjectType levelObjectType){
        super();

        JSONObject obj = objects.getJSONObject(levelObjectName);
        String levelObjectTextureFileName = obj.getString("textureFileName");

        switch (levelObjectType) {
            case LevelObjectType.FRAGILE_PLATFORM:
            case LevelObjectType.SPAWNPOINT:
            case LevelObjectType.PLATFORM:
                this.texture = new Image("file:" + ResourceManager.PLATFORMS_FOLDER + levelObjectTextureFileName);
                break;
            case LevelObjectType.DECORATION:
                this.texture = new Image("file:" + ResourceManager.DECORATIONS_FOLDER + levelObjectTextureFileName);
                break;
            case LevelObjectType.BOSS:
            case LevelObjectType.ENEMY:
                this.texture = new Image("file:" + ResourceManager.ENEMIES_FOLDER + levelObjectTextureFileName);
                break;
            default:
                break;
        }

        this.textureScaleFactor = obj.getDouble("scaleFactor");
        
        ImageView texturePreview = new ImageView(this.texture);
        this.levelObjectNameLabel = new Label(levelObjectName);
        texturePreview.setFitWidth(this.texture.getWidth() / 4);
        texturePreview.setFitHeight(this.texture.getHeight() / 4);
        this.getChildren().addAll(this.levelObjectNameLabel, texturePreview);
        this.levelObjectType = levelObjectType;
    }

    public Image getTexture(){return this.texture;}
    public double getTextureScaleFactor(){return this.textureScaleFactor;};
    public Label getLevelObjectNameLabel(){return this.levelObjectNameLabel;}
    public LevelObjectType getLevelObjectType(){return this.levelObjectType;}
}
fin fichier ./src/view/editor/EditorLevelObjectSelectorView.java





début fichier ./src/view/editor/EditorMenuBarView.java
package src.view.editor;

import java.util.HashMap;
import java.util.Map;

import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar;
import javafx.scene.control.MenuItem;
import javafx.scene.control.SeparatorMenuItem;
import src.common.ResourceManager;
import src.controller.editor.EditorMenuBarController;

public class EditorMenuBarView extends MenuBar{
    private Map<String, MenuItem> items;
    EditorMenuBarController controller;
    

    public EditorMenuBarView(EditorMenuBarController controller){
        super();
        this.controller = controller;
        this.items = new HashMap<>();

        //Création du menu "Fichier"
        Menu fileMenu = new Menu(ResourceManager.getString("EditorMenuBarView_fileMenu"));
        MenuItem File_NewLevel = new MenuItem(ResourceManager.getString("EditorMenuBarView_File_NewLevel"));
        File_NewLevel.setOnAction(e -> this.controller.handleFileNewLevel());
        MenuItem File_OpenLevel = new MenuItem(ResourceManager.getString("EditorMenuBarView_File_OpenLevel"));
        File_OpenLevel.setOnAction(e -> this.controller.handleFileOpenLevel());
        MenuItem File_SaveLevel = new MenuItem(ResourceManager.getString("EditorMenuBarView_File_SaveLevel"));
        File_SaveLevel.setOnAction(e -> this.controller.handleFileSaveLevel());
        MenuItem File_DeleteLevel = new MenuItem(ResourceManager.getString("EditorMenuBarView_File_DeleteLevel"));
        File_DeleteLevel.setOnAction(e -> this.controller.handleFileDeleteLevel());
        MenuItem File_Quit = new MenuItem(ResourceManager.getString("EditorMenuBarView_File_Quit"));
        File_Quit.setOnAction(e -> this.controller.handleFileQuit());
        fileMenu.getItems().addAll(File_NewLevel, File_OpenLevel, File_SaveLevel, File_DeleteLevel, new SeparatorMenuItem(), File_Quit);



        //Création du menu "Niveau"
        Menu levelMenu = new Menu(ResourceManager.getString("EditorMenuBarView_levelMenu"));
        MenuItem Level_ChangeLevelName = new MenuItem(ResourceManager.getString("EditorMenuBarView_Level_ChangeLevelName"));
        Level_ChangeLevelName.setOnAction(e -> this.controller.handleLevelChangeLevelName());
        MenuItem Level_ChangeLevelBackground = new MenuItem(ResourceManager.getString("EditorMenuBarView_Level_ChangeLevelBackground"));
        Level_ChangeLevelBackground.setOnAction(e -> this.controller.handleLevelChangeLevelBackground());
        MenuItem Level_TestLevel = new MenuItem(ResourceManager.getString("EditorMenuBarView_Level_TestLevel"));
        Level_TestLevel.setOnAction(e -> this.controller.handleLevelTestLevel());
        levelMenu.getItems().addAll(Level_ChangeLevelName, Level_ChangeLevelBackground, Level_TestLevel);



        //Création du menu "Préférences"
        Menu preferencesMenu = new Menu(ResourceManager.getString("EditorMenuBarView_preferencesMenu"));
        MenuItem Preference_ChangeEditorTheme = new MenuItem(ResourceManager.getString("EditorMenuBarView_Preference_ChangeEditorTheme"));
        Preference_ChangeEditorTheme.setOnAction(e -> this.controller.handlePreferenceEditorTheme());
        preferencesMenu.getItems().addAll(Preference_ChangeEditorTheme);


        
        //On ajoute les menus à la barre
        this.getMenus().addAll(fileMenu, levelMenu, preferencesMenu);
    }


    public MenuItem getMenuItem(String name){
        return this.items.get(name);
    }
}
fin fichier ./src/view/editor/EditorMenuBarView.java





début fichier ./src/view/editor/GameEditorView.java
package src.view.editor;

import src.controller.editor.GameEditorController;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;
import javafx.scene.Scene;

import src.common.ResourceManager;


public class GameEditorView extends BorderPane{
    private final GameEditorController controller;
    private Stage stage;


    public GameEditorView(GameEditorController controller, Stage stage) {
        super();
        this.controller = controller;
        this.stage = stage;
        
        Scene scene = new Scene(this, ResourceManager.resolutionWidth, ResourceManager.resolutionHeight);
        scene.getStylesheets().add(getClass().getResource("/css/steampunk.css").toString());
        stage.setScene(scene); 
        stage.setResizable(true);
    }

    public GameEditorController getController() {return this.controller;}
    public Stage getStage() {return this.stage;}
}
fin fichier ./src/view/editor/GameEditorView.java





début fichier ./src/view/editor/MapEditorView.java
package src.view.editor;

import java.beans.PropertyChangeEvent;
import java.nio.channels.Pipe.SourceChannel;
import javafx.util.Duration;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import javafx.animation.RotateTransition;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.control.RadioButton;
import javafx.scene.control.ScrollBar;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.Slider;
import javafx.scene.control.Spinner;
import javafx.scene.control.SpinnerValueFactory;
import javafx.scene.control.ToggleButton;
import javafx.scene.control.ToggleGroup;
import javafx.scene.effect.Blend;
import javafx.scene.effect.BlendMode;
import javafx.scene.effect.ColorInput;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.Region;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.stage.Modality;
import javafx.stage.Stage;
import src.controller.editor.GameEditorController.LevelObjectType;
import src.common.ResourceManager;
import src.controller.editor.MapEditorController;
import src.model.game.Decoration;
import src.model.game.Enemy;
import src.model.game.Level;
import src.model.game.LevelObject;
import src.model.game.Platform;

import org.json.JSONObject;

public class MapEditorView{
    private final Color DEFAULT_COLOR = Color.rgb(255, 255, 255, 0.0); //Couleur de base d'une case : transparent
    private final Color HOVER_COLOR = Color.rgb(0, 0, 255, 0.3); //Couleur de la case sélectionnée : bleu translucide
    private final Color SELECT_COLOR = Color.rgb(0, 255, 0, 0.3); //Couleur de la case sélectionnée : rouge translucide
    private final int defaultCellSize = 16;
    private MapEditorController controller;
    private ScrollPane mainRegion;
    private HBox settingsRegion;
    private StackPane layers;
    private Pane backgroundLayer;
    private Pane behindLayer;
    private Pane mainLayer;
    private Pane foregroundLayer;
    private GridPane gridPane;
    private int gridPaneNbRows;
    private int gridPaneNbCols;
    private int cellSize;
    private ImageView selectedLevelObjectImage = null;
    private ObjectProperty<ImageView> clickSelectedLevelObjectImage = null;
    private Pane selectedLevelObjectImageCorrespondingPane = null;
    

    public MapEditorView(MapEditorController controller, Level level){
        this.controller = controller;
        this.cellSize = defaultCellSize;
        this.mainRegion = new ScrollPane();
        this.settingsRegion = new HBox();
        this.layers = new StackPane();
        this.backgroundLayer = new Pane();
        this.behindLayer = new Pane();
        this.mainLayer = new Pane();
        this.foregroundLayer = new Pane();
        this.gridPane = new GridPane();
        this.gridPane.setGridLinesVisible(true);
        this.layers.getChildren().addAll(backgroundLayer, behindLayer, mainLayer, foregroundLayer, gridPane);
        this.mainRegion.setContent(this.layers);
        
        this.clickSelectedLevelObjectImage = new SimpleObjectProperty<>();
        this.clickSelectedLevelObjectImage.addListener((observable, oldValue, newValue) -> {if (oldValue != null) oldValue.setEffect(null);});


        this.gridPaneNbRows = (int)level.getLevelHeight() / this.cellSize;
        this.gridPaneNbCols = (int)level.getLevelWidth() / this.cellSize;

        initMainRegion();
        initGridPane();
        initSettingsRegion();
        showLevel(level);
    }

    public ScrollPane getMainRegion(){return this.mainRegion;}
    public HBox getSettingsRegion(){return this.settingsRegion;}




    private void initMainRegion(){
        this.mainRegion.addEventFilter(ScrollEvent.ANY, event -> {
            //On utilise addEventFilter sur ScrollEvent.ANY pour retirer celui que le ScrollPane avait de base
            //qui scrollait verticalement mais pour la map qui est étendue horizontalement c'est mieux que
            //le scroll soit horizontal.

            if (event.getDeltaY() != 0) {
                //Si la molette défile verticalement, on défile horizontalement
                this.mainRegion.setHvalue(this.mainRegion.getHvalue() - (event.getDeltaY() / 1000));
            }
            event.consume();
        });
    }




    private void initSettingsRegion(){
        this.settingsRegion.setSpacing(10);
        this.settingsRegion.setAlignment(Pos.CENTER);
        this.settingsRegion.getStyleClass().add("main-region");


        VBox shownLayerSelection = new VBox();
        HBox.setHgrow(shownLayerSelection, Priority.ALWAYS);
        ToggleGroup rbGroup = new ToggleGroup();
        for (int i = 0; i <= 4; i++) {
            String rbText;
            switch (i) {
                case 0:
                    rbText = ResourceManager.getString("initSettingsRegion_0");
                    break;
                case 1:
                    rbText = ResourceManager.getString("initSettingsRegion_1");
                    break;
                case 2:
                    rbText = ResourceManager.getString("initSettingsRegion_2");
                    break;
                case 3:
                    rbText = ResourceManager.getString("initSettingsRegion_3");
                    break;
                default:
                    rbText = ResourceManager.getString("initSettingsRegion_default");
                    break;
            }
            RadioButton rb = new RadioButton(rbText);
            rb.setToggleGroup(rbGroup);
            rb.setUserData(i); // associe la valeur 0-4
            shownLayerSelection.getChildren().add(rb);
        }
        // Mise à jour du label lorsqu'une sélection change
        rbGroup.selectedToggleProperty().addListener((obs, oldToggle, newToggle) -> {
            if (newToggle != null) {
                if((int)newToggle.getUserData() == 4){
                    for (Node layer : this.layers.getChildren()) {
                        if(!(layer instanceof GridPane)) layer.setVisible(true);
                    }
                }else{
                    for (Node layer : this.layers.getChildren()) {
                        if(!(layer instanceof GridPane)) layer.setVisible(false);
                    }
                    this.layers.getChildren().get((int)newToggle.getUserData()).setVisible(true);
                }
            }
        });

        VBox buttonsRegion = new VBox(10);
        buttonsRegion.setAlignment(Pos.CENTER);
        HBox.setHgrow(buttonsRegion, Priority.ALWAYS);
        //Le toggle bouton pour masque le cadrillage
        ToggleButton gridLinesVisible = new ToggleButton(ResourceManager.getString("initSettingsRegion_gridLinesVisible_hide"));
        gridLinesVisible.selectedProperty().addListener((obs, wasSelected, isNowSelected) -> {
            gridLinesVisible.setText(isNowSelected ? ResourceManager.getString("initSettingsRegion_gridLinesVisible_show") : ResourceManager.getString("initSettingsRegion_gridLinesVisible_hide"));
            gridPane.setGridLinesVisible(!isNowSelected);
        });
        buttonsRegion.getChildren().add(gridLinesVisible);

        //La region pour selectionner la taille des cellules
        VBox changeCellSizeRegion = new VBox(10);
        changeCellSizeRegion.setAlignment(Pos.CENTER);
        HBox.setHgrow(changeCellSizeRegion, Priority.ALWAYS);
        Label currCellSizeLabel = new Label(ResourceManager.getString("initSettingsRegion_currCellSizeLabel")+ this.cellSize);
        
        Spinner<Integer> spinner = new Spinner<>();
        ObservableList<Integer> values = FXCollections.observableArrayList(16, 32, 64, 128);
        SpinnerValueFactory<Integer> valueFactory = new SpinnerValueFactory.ListSpinnerValueFactory<>(values);
        spinner.setValueFactory(valueFactory);
        spinner.getValueFactory().setValue(16);
        spinner.valueProperty().addListener((obs, oldVal, newVal) -> {
            this.cellSize = newVal;
            initGridPane();
        });

        changeCellSizeRegion.getChildren().addAll(currCellSizeLabel, spinner);


        Region spacer = new Region();
        Region spacer2 = new Region();
        HBox.setHgrow(spacer, Priority.ALWAYS);
        HBox.setHgrow(spacer2, Priority.ALWAYS);

        


        

        //On ajoute tout à la region des settings
        this.settingsRegion.getChildren().addAll(shownLayerSelection, spacer, changeCellSizeRegion, spacer2, buttonsRegion);        
    }






    public void updateSelectedLevelObjectImage(String levelObjectName){
        if(levelObjectName == null){
            this.selectedLevelObjectImage = null;
            this.selectedLevelObjectImageCorrespondingPane = null;
            return;
        }

        String pathToLevelObjectTexture = null;
        double scaleFactor = 1.0;
        if(ResourceManager.PLATFORMS_JSON.has(levelObjectName)){
            pathToLevelObjectTexture = ResourceManager.PLATFORMS_FOLDER + ResourceManager.PLATFORMS_JSON.getJSONObject(levelObjectName).getString("textureFileName");
            this.selectedLevelObjectImageCorrespondingPane = this.mainLayer;
            scaleFactor = ResourceManager.PLATFORMS_JSON.getJSONObject(levelObjectName).getDouble("scaleFactor");
        }else if(ResourceManager.DECORATIONS_JSON.has(levelObjectName)){
            pathToLevelObjectTexture = ResourceManager.DECORATIONS_FOLDER + ResourceManager.DECORATIONS_JSON.getJSONObject(levelObjectName).getString("textureFileName");
            this.selectedLevelObjectImageCorrespondingPane = this.behindLayer;
            scaleFactor = ResourceManager.DECORATIONS_JSON.getJSONObject(levelObjectName).getDouble("scaleFactor");
        }
        else if(ResourceManager.ENEMIES_JSON.has(levelObjectName)){
            pathToLevelObjectTexture = ResourceManager.ENEMIES_FOLDER + ResourceManager.ENEMIES_JSON.getJSONObject(levelObjectName).getString("textureFileName");
            this.selectedLevelObjectImageCorrespondingPane = this.mainLayer;
            scaleFactor = ResourceManager.ENEMIES_JSON.getJSONObject(levelObjectName).getDouble("scaleFactor");
        }
        this.selectedLevelObjectImage = new ImageView(new Image("file:" + pathToLevelObjectTexture));
        this.selectedLevelObjectImage.setOpacity(0.5);
        this.selectedLevelObjectImage.setFitHeight(this.selectedLevelObjectImage.getImage().getHeight() * scaleFactor);
        this.selectedLevelObjectImage.setFitWidth(this.selectedLevelObjectImage.getImage().getWidth() * scaleFactor);
    }

    

    private void initGridPane(){
        if(this.gridPane.getHeight() > 0){ 
            //On prend la taille du gridpane comme étant la taille du level actuellement chargé.
            //Si la hauteur ou la largeur était à 0, ça veut dire que c'est la première initialisation
            //du gridpane et il n'a pas encore été affiché donc pas de taille. Mais dans ce cas,
            //les nombres de lignes et colonnes ont été initialisé dans le constructeur
            this.gridPaneNbRows = (int)(this.gridPane.getHeight() / this.cellSize);
            this.gridPaneNbCols = (int)(this.gridPane.getWidth() / this.cellSize);
        }
        this.gridPane.getChildren().clear();
        
        
        for (int i = 0; i < this.gridPaneNbRows; i++) {
            for (int j = 0; j < this.gridPaneNbCols; j++) {
                Rectangle rect = new Rectangle(this.cellSize, this.cellSize);
                rect.setFill(this.DEFAULT_COLOR);
                this.gridPane.add(rect, j, i);
                

                //Ajout de la gestion du déplacement de la souris dans le gridpane
                rect.setOnMouseEntered((MouseEvent e) -> {
                    if(this.selectedLevelObjectImage != null){
                        Integer col = GridPane.getColumnIndex(rect);
                        Integer row = GridPane.getRowIndex(rect);
                        int colIndex = (col == null) ? 0 : col;
                        int rowIndex = (row == null) ? 0 : row;

                        this.selectedLevelObjectImageCorrespondingPane.getChildren().add(this.selectedLevelObjectImage);
                        this.selectedLevelObjectImage.setLayoutX(colIndex * cellSize);
                        this.selectedLevelObjectImage.setLayoutY(rowIndex * cellSize);
                    }
                });
                rect.setOnMouseExited((MouseEvent e) -> {
                    if(this.selectedLevelObjectImage != null){
                        this.selectedLevelObjectImageCorrespondingPane.getChildren().remove(this.selectedLevelObjectImage);
                    }
                });

                //Ajout de la gestion du clique de la souris dans le grid pane
                rect.setOnMousePressed((MouseEvent e) -> {
                    Integer col = GridPane.getColumnIndex(rect);
                    Integer row = GridPane.getRowIndex(rect);
                    int colIndex = (col == null) ? 0 : col;
                    int rowIndex = (row == null) ? 0 : row;
                    double cellTopLeftX = colIndex * cellSize;
                    double cellTopLeftY = rowIndex * cellSize;
                    this.controller.handleMouseClick(cellTopLeftX, cellTopLeftY);
                });
            }
        }


        this.gridPane.setGridLinesVisible(!this.gridPane.isGridLinesVisible());
        this.gridPane.setGridLinesVisible(!this.gridPane.isGridLinesVisible()); 
    }



    public void updateClickSelectedLevelObject(LevelObject levelObject){
        if(levelObject == null){
            this.clickSelectedLevelObjectImage.set(null);
            return;
        } 

        for (Pane panes : Arrays.asList(this.behindLayer, this.mainLayer, this.foregroundLayer)) {
            for (Node image : panes.getChildren()) {
                if(image instanceof ImageView){
                    if(image.getLayoutX() == levelObject.getX() && image.getLayoutY() == levelObject.getY()){
                        Blend blend = new Blend(
                            BlendMode.MULTIPLY,
                            null,
                            new ColorInput(0, 0, levelObject.getWidth(), levelObject.getHeight(), Color.color(0.0, 1.0, 0.0, 0.6))
                        );
                        image.setEffect(blend);
                        this.clickSelectedLevelObjectImage.set((ImageView)image);
                        return;
                    }
                    
                }
            }
        }
    }


    //On affiche visuellement le niveau en ajoutant chaque éléments sous leur forme graphique
    //dans les différente couche que contient la vue
    public void showLevel(Level level){
        //On clear tout ce qui est déjà affiché
        this.backgroundLayer.getChildren().clear();
        this.mainLayer.getChildren().clear();
        this.behindLayer.getChildren().clear();
        this.foregroundLayer.getChildren().clear();

        
        //On ajoute le background à la couche de fond
        ImageView bg = new ImageView(level.getBackgroundImage());
        this.backgroundLayer.getChildren().add(bg);
        bg.setLayoutX(0);
        bg.setLayoutY(0);
        
        //On ajoute les éléments qui vont dans la couche principale et celle de derrière
        for(LevelObject levelObject : level.getLevelObjects()){
            ImageView temp = new ImageView(levelObject.getTexture());
            temp.setFitWidth(levelObject.getWidth());
            temp.setFitHeight(levelObject.getHeight());
            temp.setLayoutX(levelObject.getX());
            temp.setLayoutY(levelObject.getY());


            if(levelObject instanceof Platform){
                this.mainLayer.getChildren().add(temp);
            }else if(levelObject instanceof Decoration){
                this.behindLayer.getChildren().add(temp);
            }else if(levelObject instanceof Enemy){
                //Si c'est un enemy on affiche en plus les limites de sa patrouille
                Enemy tempEnemy = ((Enemy)levelObject);

                Line ligne = new Line(tempEnemy.getLeftBound(), tempEnemy.getY(), tempEnemy.getRightBound(), tempEnemy.getY());
                ligne.setStroke(Color.RED);
                ligne.setStrokeWidth(3);  
                this.mainLayer.getChildren().addAll(temp, ligne);
            }
        }
    }
}
fin fichier ./src/view/editor/MapEditorView.java





début fichier ./src/view/game/GameView.java
// src/view/GameView.java
package src.view.game;

import javafx.application.Platform;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.scene.CacheHint;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.effect.Blend;
import javafx.scene.effect.BlendMode;
import javafx.scene.effect.ColorInput;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import src.common.ResourceManager;
import src.controller.game.GameController;
import src.model.game.Boss;
import src.model.game.Enemy;
import src.common.ResourceManager;

import java.util.List;
import java.util.concurrent.CountDownLatch;

public class GameView {
    private static final int WIDTH  = 800;
    private static final int HEIGHT = 600;
    private final DoubleProperty cameraX = new SimpleDoubleProperty(0);
    private final DoubleProperty cameraY = new SimpleDoubleProperty(0);
    private final GraphicsContext gc;
    private Pane root;
    private Scene scene;
    private Canvas canvas;
    private GameController controller;

    // Cache pour le background redimensionné
    private Image cachedBackground = null;
    private double cachedWidth = 0, cachedHeight = 0;

    // ------------------------------------------------------------
    // Engrenage
    // ------------------------------------------------------------
    private Image gearSpriteSheet;
    private int gearFrameIndex = 0;
    private int gearFrameCount = 0;
    private int gearFrameWidth = 0;
    private int gearFrameHeight = 0;
    private long lastGearFrameTime = 0;
    private final long gearFrameDuration = 50_000_000; // 50 ms

    // ------------------------------------------------------------
    // Joueur Idle
    // ------------------------------------------------------------
    private Image playerIdleSheet;
    private int idleFrameIndex = 0;
    private int idleFrameCount = 0;
    private int idleFrameWidth = 0;
    private int idleFrameHeight = 0;
    private long lastIdleFrameTime = 0;
    private final long idleFrameDuration = 100_000_000; // 100 ms

    // ------------------------------------------------------------
    // Joueur Walk
    // ------------------------------------------------------------
    private Image playerWalkSheet;
    private int walkFrameIndex = 0;
    private int walkFrameCount = 0;
    private int walkFrameWidth = 0;
    private int walkFrameHeight = 0;
    private long lastWalkFrameTime = 0;
    private final long walkFrameDuration = 100_000_000; // 100 ms

    // ------------------------------------------------------------
    // Joueur Jump
    // ------------------------------------------------------------
    private Image playerJumpSheet;
    private int jumpFrameIndex = 0;
    private int jumpFrameCount = 0;
    private int jumpFrameWidth = 0;
    private int jumpFrameHeight = 0;
    private long lastJumpFrameTime = 0;
    private final long jumpFrameDuration = 100_000_000; // 100 ms

    // ------------------------------------------------------------
    // Sprite du vaisseau
    // ------------------------------------------------------------
    private Image spaceshipImage;
    private final double playerOffsetY = 50;

    public GameView(GameController controller, Stage primaryStage) {
        this.controller = controller;
        root = new Pane();
        canvas = new Canvas(ResourceManager.resolutionWidth, ResourceManager.resolutionHeight);
        canvas.widthProperty().bind(root.widthProperty());
        canvas.heightProperty().bind(root.heightProperty());
        root.getChildren().add(canvas);
        scene = new Scene(root, ResourceManager.resolutionWidth, ResourceManager.resolutionHeight);
        primaryStage.setScene(scene);
        primaryStage.setResizable(true);

        this.gc = canvas.getGraphicsContext2D();
        canvas.setCache(true);
        canvas.setCacheHint(CacheHint.SPEED);

        try {
            // Engrenage
            gearSpriteSheet = new Image("file:" + ResourceManager.TEXTURES_FOLDER + "engrenage_animation-Sheet.png");
            if (!gearSpriteSheet.isError()) {
                gearFrameHeight = (int) gearSpriteSheet.getHeight();
                gearFrameWidth  = gearFrameHeight;
                if (gearFrameWidth != 0) {
                    gearFrameCount = (int) (gearSpriteSheet.getWidth() / gearFrameWidth);
                }
            }

            // Joueur Idle
            playerIdleSheet = new Image("file:" + ResourceManager.TEXTURES_FOLDER + "static wrench-Sheet.png");
            if (!playerIdleSheet.isError()) {
                idleFrameHeight = (int) playerIdleSheet.getHeight();
                idleFrameWidth  = idleFrameHeight;
                if (idleFrameWidth != 0) {
                    idleFrameCount = (int) (playerIdleSheet.getWidth() / idleFrameWidth);
                }
            }

            // Joueur Walk
            playerWalkSheet = new Image("file:"+ ResourceManager.TEXTURES_FOLDER +"sprite sheet wrench walking.png");
            if (!playerWalkSheet.isError()) {
                walkFrameHeight = (int) playerWalkSheet.getHeight();
                walkFrameWidth  = walkFrameHeight;
                if (walkFrameWidth != 0) {
                    walkFrameCount = (int) (playerWalkSheet.getWidth() / walkFrameWidth);
                }
            }

            // Joueur Jump
            playerJumpSheet = new Image("file:" + ResourceManager.TEXTURES_FOLDER + "jump2 wrench-Sheet.png");
            if (!playerJumpSheet.isError()) {
                jumpFrameHeight = (int) playerJumpSheet.getHeight();
                jumpFrameWidth  = jumpFrameHeight;
                if (jumpFrameWidth != 0) {
                    jumpFrameCount = (int) (playerJumpSheet.getWidth() / jumpFrameWidth);
                }
            }

            // Sprite vaisseau
            spaceshipImage = new Image("file:" + ResourceManager.TEXTURES_FOLDER + "dirigeable v1.png");
        } catch (Exception e) {
            System.err.println("Exception loading images: " + e.getMessage());
        }
    }

    /**
     * Retourne une version redimensionnée du background (thread-safe).
     */
    private Image getScaledBackground(Image background, double width, double height) {
        if (Platform.isFxApplicationThread()) {
            return createScaledBackground(background, width, height);
        } else {
            final Image[] result = new Image[1];
            final CountDownLatch latch = new CountDownLatch(1);
            Platform.runLater(() -> {
                result[0] = createScaledBackground(background, width, height);
                latch.countDown();
            });
            try {
                latch.await();
            } catch (InterruptedException ignored) {}
            return result[0];
        }
    }

    private Image createScaledBackground(Image background, double width, double height) {
        Canvas temp = new Canvas(width, height);
        GraphicsContext gc2 = temp.getGraphicsContext2D();
        gc2.drawImage(background, 0, 0, width, height);
        WritableImage wi = new WritableImage((int) width, (int) height);
        temp.snapshot(null, wi);
        return wi;
    }

    /**
     * Dessine la frame complète, avec décorations, plateformes, ennemis et projectiles.
     */
    public void draw(
        Image background,
        double playerX, double playerY,
        double playerW, double playerH,
        boolean isWalking, boolean facingRight,
        boolean isJumping, boolean spaceshipMode,
        List<Image> decorationImages,
        List<Double[]> decorationPositions,
        List<Image> platformImages,
        List<Double[]> platformPositions,
        List<Enemy> enemies,
        List<Double[]> projectilePositions
    ) {
        double cw = gc.getCanvas().getWidth();
        double ch = gc.getCanvas().getHeight();

        // Fond noir
        gc.setFill(Color.BLACK);
        gc.fillRect(0, 0, cw, ch);

        // Background mis à l’échelle + cache
        if (background != null) {
            if (cachedBackground == null || cachedWidth != cw || cachedHeight != ch) {
                cachedBackground = getScaledBackground(background, cw, ch);
                cachedWidth = cw; cachedHeight = ch;
            }
            gc.drawImage(cachedBackground, 0, 0);
        }

        // Engrenage
        if (gearSpriteSheet != null && gearFrameWidth > 0) {
            long now = System.nanoTime();
            if (now - lastGearFrameTime >= gearFrameDuration) {
                gearFrameIndex = (gearFrameIndex + 1) % gearFrameCount;
                lastGearFrameTime = now;
            }
            int sx = gearFrameIndex * gearFrameWidth;
            gc.drawImage(gearSpriteSheet,
                         sx, 0, gearFrameWidth, gearFrameHeight,
                         0, 0, gearFrameWidth, gearFrameHeight);
        }

        // 1) Décorations
        for (int i = 0; i < decorationImages.size(); i++) {
            Image img = decorationImages.get(i);
            Double[] pos = decorationPositions.get(i);
            double dx = pos[0] - cameraX.get();
            double dy = pos[1] - cameraY.get();
            double dw = pos[2], dh = pos[3];
            if (img != null) {
                gc.drawImage(img, dx, dy, dw, dh);
            }
        }

        // 2) Plateformes
        for (int i = 0; i < platformImages.size(); i++) {
            Image img = platformImages.get(i);
            Double[] pos = platformPositions.get(i);
            double px = pos[0] - cameraX.get();
            double py = pos[1] - cameraY.get();
            double pw = pos[2], ph = pos[3];
            if (img != null) {
                gc.drawImage(img, px, py, pw, ph);
            } else {
                gc.setFill(Color.BLUE);
                gc.fillRect(px, py, pw, ph);
            }
        }

        // 3) JOUEUR ou VAISSEAU
        double drawX = playerX - cameraX.get();
        double drawY = playerY - cameraY.get() - playerOffsetY;
        if (spaceshipMode && spaceshipImage != null) {
            double imageW = spaceshipImage.getWidth();
            double imageH = spaceshipImage.getHeight();
            double targetH = playerH * 2.0;
            double targetW = targetH * (imageW / imageH);

            if (facingRight) {
                gc.drawImage(spaceshipImage,
                             drawX, drawY,
                             targetW, targetH);
            } else {
                gc.save();
                gc.translate(drawX + targetW, drawY);
                gc.scale(-1, 1);
                gc.drawImage(spaceshipImage,
                             0, 0,
                             targetW, targetH);
                gc.restore();
            }
        } else if (isJumping && playerJumpSheet != null && jumpFrameWidth > 0) {
            long now = System.nanoTime();
            if (now - lastJumpFrameTime >= jumpFrameDuration) {
                jumpFrameIndex = (jumpFrameIndex + 1) % jumpFrameCount;
                lastJumpFrameTime = now;
            }
            int sx = jumpFrameIndex * jumpFrameWidth;
            if (facingRight) {
                gc.drawImage(playerJumpSheet,
                             sx, 0, jumpFrameWidth, jumpFrameHeight,
                             drawX, drawY, playerW * 2, playerH * 2);
            } else {
                gc.save();
                gc.translate(drawX + playerW * 2, drawY);
                gc.scale(-1, 1);
                gc.drawImage(playerJumpSheet,
                             sx, 0, jumpFrameWidth, jumpFrameHeight,
                             0, 0, playerW * 2, playerH * 2);
                gc.restore();
            }
        } else if (isWalking && playerWalkSheet != null && walkFrameWidth > 0) {
            long now = System.nanoTime();
            if (now - lastWalkFrameTime >= walkFrameDuration) {
                walkFrameIndex = (walkFrameIndex + 1) % walkFrameCount;
                lastWalkFrameTime = now;
            }
            int sx = walkFrameIndex * walkFrameWidth;
            if (facingRight) {
                gc.drawImage(playerWalkSheet,
                             sx, 0, walkFrameWidth, walkFrameHeight,
                             drawX, drawY, playerW * 2, playerH * 2);
            } else {
                gc.save();
                gc.translate(drawX + playerW * 2, drawY);
                gc.scale(-1, 1);
                gc.drawImage(playerWalkSheet,
                             sx, 0, walkFrameWidth, walkFrameHeight,
                             0, 0, playerW * 2, playerH * 2);
                gc.restore();
            }
        } else if (playerIdleSheet != null && idleFrameWidth > 0) {
            long now = System.nanoTime();
            if (now - lastIdleFrameTime >= idleFrameDuration) {
                idleFrameIndex = (idleFrameIndex + 1) % idleFrameCount;
                lastIdleFrameTime = now;
            }
            int sx = idleFrameIndex * idleFrameWidth;
            if (facingRight) {
                gc.drawImage(playerIdleSheet,
                             sx, 0, idleFrameWidth, idleFrameHeight,
                             drawX, drawY, playerW * 2, playerH * 2);
            } else {
                gc.save();
                gc.translate(drawX + playerW * 2, drawY);
                gc.scale(-1, 1);
                gc.drawImage(playerIdleSheet,
                             sx, 0, idleFrameWidth, idleFrameHeight,
                             0, 0, playerW * 2, playerH * 2);
                gc.restore();
            }
        }

        
        // 4) Ennemis + boss
        for (Enemy e : enemies) {
            double ex = e.getX() - cameraX.get();
            double ey = e.getY() - cameraY.get();
            double ew = e.getWidth(), eh = e.getHeight();
            Image img = e.getTexture();
            if (e instanceof Boss && ((Boss) e).isHit()) {
                ImageView temp = new ImageView(img);
                Blend blend = new Blend(
                    BlendMode.HARD_LIGHT,
                    null,
                    new ColorInput(0, 0, e.getWidth(), e.getHeight(), Color.color(1.0, 0.0, 0.0, 0.7))
                );
                temp.setEffect(blend);
                WritableImage writableImage = new WritableImage((int) img.getWidth(), (int) img.getHeight());
                temp.snapshot(null, writableImage);
                gc.drawImage(writableImage, ex, ey, ew, eh);
            } else {
                gc.drawImage(img, ex, ey, ew, eh);
            }
        }

        // 5) Projectiles (mode vaisseau)
        if (spaceshipMode) {
            gc.setFill(Color.RED);
            for (Double[] pos : projectilePositions) {
                double px = pos[0] - cameraX.get();
                double py = pos[1] - cameraY.get();
                double pw = pos[2], ph = pos[3];
                gc.fillRect(px, py, pw, ph);
            }
        }
    }

    public DoubleProperty cameraXProperty() { return cameraX; }
    public DoubleProperty cameraYProperty() { return cameraY; }
    public double getCanvasWidth()        { return gc.getCanvas().getWidth(); }
    public double getCanvasHeight()       { return gc.getCanvas().getHeight(); }

    public void resetBackgroundCache() {
        this.cachedBackground = null;
        this.cachedWidth  = -1;
        this.cachedHeight = -1;
    }

    public Scene getScene(){
        return this.scene;
    }
}
fin fichier ./src/view/game/GameView.java





début fichier ./src/view/MainMenuView.java
package src.view;

import java.util.Locale;


import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.layout.VBox;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.stage.Modality;
import javafx.stage.Stage;
import src.common.ResourceManager;
import src.controller.MainMenuController;
import javafx.scene.control.Label;

public class MainMenuView extends VBox {
    MainMenuController controller;

    public MainMenuView(MainMenuController controller, Stage primaryStage){
        super(10);
        this.setAlignment(Pos.CENTER);
        this.getStyleClass().add("main-region");


        Scene scene = new Scene(this, ResourceManager.resolutionWidth, ResourceManager.resolutionHeight);
        scene.getStylesheets().add(getClass().getResource("/css/steampunk.css").toString());
        primaryStage.setScene(scene);
        primaryStage.centerOnScreen();


        this.controller = controller;

        Button game = new Button(ResourceManager.getString("start_game"));
        game.setOnAction(e -> {this.controller.startGame(primaryStage);});

        Button editor = new Button(ResourceManager.getString("start_editor"));
        editor.setOnAction(e -> {this.controller.startEditor(primaryStage);});



        // --- CONFIGURATIONS ---
        Label configLabel = new Label("—————————— " + ResourceManager.getString("configTitle") + " ——————————");
        configLabel.setFont(Font.font("System", FontWeight.BOLD, 20));

        Button showKeysButton = new Button(ResourceManager.getString("show_keys_title"));
        showKeysButton.setOnAction(e -> showKeysWindow());


        Label resolutionLabel = new Label(ResourceManager.getString("resolution_title"));
        ComboBox<String> resolutionCombo = new ComboBox<>();
        resolutionCombo.getItems().addAll("1920x1080", "1280x720");
        resolutionCombo.setValue(ResourceManager.resolutionWidth + "x" + ResourceManager.resolutionHeight); 
        resolutionCombo.setOnAction(e -> {this.controller.handleResolutionChange(resolutionCombo.getValue());});


        Label languageLabel = new Label(ResourceManager.getString("select_language"));
        ComboBox<String> languageSelection = new ComboBox<>();
        languageSelection.getItems().addAll("Français", "English");
        if (Locale.ENGLISH.equals(ResourceManager.getLocale())) {
            languageSelection.setValue("English");
        } else if (Locale.FRENCH.equals(ResourceManager.getLocale())) {
            languageSelection.setValue("Français");
        } else {
            languageSelection.setValue("English");
        }
        
        languageSelection.setOnAction(event -> { this.controller.handleLanguageChange(languageSelection.getValue());});

        VBox configsVBox = new VBox(15);
        configsVBox.setAlignment(Pos.CENTER);
        configsVBox.setStyle("-fx-padding: 20");

        configsVBox.getChildren().addAll(
                configLabel,
                showKeysButton,
                resolutionLabel,
                resolutionCombo,
                languageLabel,
                languageSelection
        );




        // --- AUTEURS ---
        Label authorTitle = new Label("—————————— " + ResourceManager.getString("authorTitle") + " ——————————");
        Label nom1 = new Label("Matthieu PETIT");
        Label nom2 = new Label("Zack HÉBERT");
        Label nom3 = new Label("Erwann BRICET");

        // Mise en page verticale
        VBox authorVBox = new VBox(10); // 10 pixels d'espacement
        authorVBox.setAlignment(Pos.CENTER);
        authorVBox.getChildren().addAll(authorTitle, nom1, nom2, nom3);



        this.getChildren().addAll(game, editor, configsVBox, authorVBox);


    }


    private void showKeysWindow() {
        Stage keysStage = new Stage();
        keysStage.initModality(Modality.APPLICATION_MODAL);
        VBox layout = new VBox(10);
        layout.getStyleClass().add("main-region");
        layout.setStyle("-fx-padding: 10");
        layout.getChildren().add(new Label(ResourceManager.getString("keys_list")));
        Scene scene = new Scene(layout, 600, 600);
        scene.getStylesheets().add(getClass().getResource("/css/steampunk.css").toString());
        keysStage.setTitle(ResourceManager.getString("keys_list_title"));
        keysStage.setScene(scene);
        keysStage.showAndWait();
    }
}
fin fichier ./src/view/MainMenuView.java





début fichier ./.vscode/launch.json

{
"version": "0.2.0",
"configurations": [
    {
        "type": "java",
        "name": "Launch Game",
        "request": "launch",
        "mainClass": "src.Game",
        "vmArgs": "--module-path matthieu/Documents/zulu21.38.21-ca-fx-jdk21.0.5-linux_x64/lib --add-modules javafx.controls,javafx.fxml"
    }
]
}fin fichier ./.vscode/launch.json





