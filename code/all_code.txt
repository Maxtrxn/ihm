début fichier ./src/controller/GameController.java
package src.controller;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import javafx.animation.AnimationTimer;
import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
import javafx.scene.image.Image;

import src.Game;
import src.levels.Level;
import src.levels.Level1;
import src.levels.Level2;
import src.levels.Level3;
import src.levels.SpaceshipLevel;
import src.model.Player;
import src.model.Platform;
import src.model.Enemy;
import src.model.Projectile;
import src.model.Decoration;
import src.view.GameView;

public class GameController {
    private static final double GRAVITY = 1800.0;

    // Flags de déplacement
    private boolean left, right, up, down, jumping, jetpack;

    private final Player player;
    private final List<Platform> platforms;
    private final List<Enemy> enemies;
    private final List<Decoration> decorations;
    private final List<Projectile> projectiles = new ArrayList<>();
    private final GameView view;
    private final Game game;
    private final Level level;

    private final double initialPlayerX, initialPlayerY;
    private Timer jetpackTimer;

    // Dimensions logiques du niveau
    private final double levelWidth  = 3000.0;
    private final double levelHeight = 600.0;

    // Caméra
    private double cameraX = 0.0, cameraY = 0.0;

    // Boucle JavaFX
    private AnimationTimer gameLoop;

    public GameController(Player player,
                          List<Platform> platforms,
                          List<Enemy> enemies,
                          List<Decoration> decorations,
                          GameView view,
                          Game game,
                          Level level) {
        this.player          = player;
        this.platforms       = platforms;
        this.enemies         = enemies;
        this.decorations     = decorations;
        this.view            = view;
        this.game            = game;
        this.level           = level;
        this.initialPlayerX  = player.getX();
        this.initialPlayerY  = player.getY();
    }

    /** Lie les touches aux flags, et gère tirs vs saut. */
    public void handleInput(Scene scene) {
        scene.setOnKeyPressed(e -> {
            if (e.getCode() == KeyCode.LEFT)  left  = true;
            if (e.getCode() == KeyCode.RIGHT) right = true;
            if (e.getCode() == KeyCode.UP)    up    = true;
            if (e.getCode() == KeyCode.DOWN)  down  = true;

            if (e.getCode() == KeyCode.SPACE) {
                if (level instanceof SpaceshipLevel) {
                    fireProjectile();
                } else {
                    jumping = true;
                    if (jetpackTimer == null) {
                        jetpackTimer = new Timer(true);
                        jetpackTimer.schedule(new JetpackTask(), 500L);
                    }
                }
            }
        });

        scene.setOnKeyReleased(e -> {
            if (e.getCode() == KeyCode.LEFT)  left  = false;
            if (e.getCode() == KeyCode.RIGHT) right = false;
            if (e.getCode() == KeyCode.UP)    up    = false;
            if (e.getCode() == KeyCode.DOWN)  down  = false;

            if (e.getCode() == KeyCode.SPACE && !(level instanceof SpaceshipLevel)) {
                jumping = false;
                jetpack = false;
                player.setJetpackActive(false);
                if (jetpackTimer != null) {
                    jetpackTimer.cancel();
                    jetpackTimer = null;
                }
            }
        });
    }

    /** Démarre la boucle via AnimationTimer. */
    public void startGameLoop() {
        gameLoop = new AnimationTimer() {
            private long lastTime = 0;
            @Override
            public void handle(long now) {
                if (lastTime == 0) {
                    lastTime = now;
                    return;
                }
                double deltaSec = (now - lastTime) / 1_000_000_000.0;
                update(deltaSec);
                lastTime = now;
            }
        };
        gameLoop.start();
    }



    /** Stoppe proprement la boucle en cours. */
    public void stopGameLoop() {
        if (gameLoop != null) {
            gameLoop.stop();
        }
    }

    /**
     * Une itération de la boucle (~60FPS), délègue le passage de niveau à Game.nextLevel().
     * @param deltaSec  Temps écoulé (s) depuis la dernière frame
     */
    private void update(double deltaSec) {
        boolean isSpaceship = level instanceof SpaceshipLevel;

        // Calcul du déplacement horizontal en px pour ce frame
        double dx    = 0.0;
        double speed = player.getSpeed() * 1.5; // px/sec
        if (left)  { dx -= speed * deltaSec; player.setFacingRight(false); }
        if (right) { dx += speed * deltaSec; player.setFacingRight(true); }

        // Mode vaisseau ou plateforme
        if (isSpaceship) {
            updateSpaceship(dx, deltaSec);
            updateProjectiles(deltaSec);
        } else {
            updatePlatform(dx, deltaSec);
        }

        // Passage de niveau si on dépasse X = 1600
        if (player.getX() > 1600.0) {
            javafx.application.Platform.runLater(() -> game.nextLevel());
        }

        // Caméra + rendu
        updateCamera(isSpaceship);
        render(isSpaceship);
    }



    /** @param dx      déplacement horizontal pour ce frame
     *  @param deltaSec  temps écoulé (s)
     */
    private void updateSpaceship(double dx, double deltaSec) {
        double dy = 0.0;
        double shipSpeed = player.getSpeed() * 1.5; // px/sec
        if (up)   dy -= shipSpeed * deltaSec;
        if (down) dy += shipSpeed * deltaSec;
        player.move(dx, dy);
    }



    /** @param deltaSec  temps écoulé (s) */
    private void updateProjectiles(double deltaSec) {
        Iterator<Projectile> pit = projectiles.iterator();
        while (pit.hasNext()) {
            Projectile p = pit.next();
            p.update(deltaSec);
            if (p.isOutOfBounds(levelWidth)) {
                pit.remove();
                continue;
            }
            Iterator<Enemy> eit = enemies.iterator();
            while (eit.hasNext()) {
                Enemy enemy = eit.next();
                if (p.intersects(enemy)) {
                    eit.remove();
                    pit.remove();
                    break;
                }
            }
        }
    }


    /** Tire un nouveau projectile depuis la position du joueur. */
    private void fireProjectile() {
        double offsetX = player.isFacingRight()
                       ? player.getWidth()
                       : -10;
        double px = player.getX() + offsetX;
        double py = player.getY() + player.getHeight() / 2.0;
        projectiles.add(new Projectile(px, py, player.isFacingRight()));
    }




    /**
     * @param dx       déplacement horizontal pour ce frame (px)
     * @param deltaSec temps écoulé (s) depuis la dernière frame
     */
    private void updatePlatform(double dx, double deltaSec) {
        // Mémorise la position Y AVANT le déplacement
        double oldY = player.getY();

        // déclenchement du saut : on passe à -600 px/s (~-10 px/frame @60FPS)
        if (jumping && player.canJump() && !jetpack) {
            player.setVelocityY(-603.0);
            player.setOnGround(false);
            player.incrementJumps();
            jumping = false;
        }

        // jetpack : vitesse de montée constante (px/s)
        if (jetpack && player.isJetpackActive()) {
            player.setVelocityY(-300.0);
        } else {
            // intégration de la gravité en px/s²
            player.setVelocityY(player.velocityY + GRAVITY * deltaSec);
        }

        // déplacement vertical selon deltaSec
        double dy = player.velocityY * deltaSec;
        player.move(dx, dy);

        // collisions plateformes en tenant compte de oldY
        handlePlatformCollisions(oldY);

        // gestion des ennemis
        handleEnemies(deltaSec);

        // reset si chute
        if (player.getY() > levelHeight) {
            resetPlayerPosition();
        }
    }





    /**
     * Gère les collisions plateforme en s’assurant que le joueur
     * venait bien d’au-dessus de la plateforme.
     *
     * @param oldY position Y du joueur AVANT le move(...)
     */
    private void handlePlatformCollisions(double oldY) {
        // 1) Reset fragile platforms
        for (Platform p : platforms) {
            if (p instanceof src.model.platforms.FragilePlatform) {
                ((src.model.platforms.FragilePlatform) p).resetStep(player);
            }
        }

        // 2) Test d’atterrissage
        for (Platform p : platforms) {
            double platformTop     = p.getY();
            double playerBottomNow = player.getY() + player.getHeight();
            double playerBottomOld = oldY            + player.getHeight();

            if (player.intersects(p)
                && player.velocityY > 0.0
                && playerBottomOld <= platformTop
            ) {
                // Pose le joueur exactement sur la plateforme
                player.setY(platformTop - player.getHeight());
                player.velocityY = 0.0;
                player.setOnGround(true);
                player.resetJumps();

                // Si plateforme fragile, incrémente son état
                if (p instanceof src.model.platforms.FragilePlatform) {
                    src.model.platforms.FragilePlatform fp =
                        (src.model.platforms.FragilePlatform) p;
                    if (!fp.isBroken()) {
                        fp.step(player);
                    }
                }
            }
        }
    }


    /**
     * @param deltaSec  temps écoulé (s) depuis la dernière frame
     */
    private void handleEnemies(double deltaSec) {
        List<Enemy> toRemove = new ArrayList<>();
        for (Enemy enemy : enemies) {
            // déplacement de l’ennemi à la bonne vitesse (px/s)
            enemy.update(deltaSec);

            if (player.landsOn(enemy)) {
                toRemove.add(enemy);
                player.setVelocityY(-600.0); // rebond identique au saut
            } else if (player.intersects(enemy)) {
                resetPlayerPosition();
            }
        }
        enemies.removeAll(toRemove);
    }



    private void updateCamera(boolean isSpaceship) {
        double cw = view.getCanvasWidth();
        double ch = view.getCanvasHeight();

        // X
        double targetX = player.getX() - cw / 2.0;
        cameraX += 0.1 * (targetX - cameraX);
        cameraX = Math.max(0, Math.min(cameraX, levelWidth - cw));

        // Y
        if (isSpaceship) {
            cameraY = 0;
        } else if (ch > levelHeight) {
            cameraY = levelHeight - ch;
        } else {
            double targetY = player.getY() - ch / 2.0;
            cameraY += 0.1 * (targetY - cameraY);
            cameraY = Math.max(0, Math.min(cameraY, levelHeight - ch));
        }

        view.cameraXProperty().set(cameraX);
        view.cameraYProperty().set(cameraY);
    }

    /** Dessine décors, plateformes, ennemis, projectiles, joueur/vaisseau. */
    private void render(boolean isSpaceship) {
        // Décorations
        List<Image> decoImgs = new ArrayList<>();
        List<Double[]> posDeco = new ArrayList<>();
        for (Decoration d : decorations) {
            decoImgs.add(d.getTexture());
            posDeco.add(new Double[]{ d.getX(), d.getY(), d.getWidth(), d.getHeight() });
        }

        // Plateformes
        List<Image> imgs     = new ArrayList<>();
        List<Double[]> posPl = new ArrayList<>();
        for (Platform p : platforms) {
            imgs.add(p.getTexture());
            posPl.add(new Double[]{ p.getX(), p.getY(), p.getWidth(), p.getHeight() });
        }

        // Ennemis
        List<Double[]> posEn = new ArrayList<>();
        for (Enemy e : enemies) {
            posEn.add(new Double[]{ e.getX(), e.getY(), e.getWidth(), e.getHeight() });
        }

        // Projectiles
        List<Double[]> posProj = new ArrayList<>();
        for (Projectile p : projectiles) {
            posProj.add(new Double[]{ p.getX(), p.getY(), p.getWidth(), p.getHeight() });
        }

        boolean isJumping = !player.onGround;
        view.draw(
            level.getBackgroundImage(),
            player.getX(), player.getY(),
            player.getWidth(), player.getHeight(),
            player.isWalking(), player.isFacingRight(),
            isJumping,
            isSpaceship,
            decoImgs, posDeco,
            imgs, posPl,
            posEn,
            posProj
        );
    }

    private void resetPlayerPosition() {
        player.setX(initialPlayerX);
        player.setY(initialPlayerY);
        player.velocityY    = 0.0;
        player.setOnGround(true);
        player.resetJumps();
        player.setJetpackActive(false);
        if (jetpackTimer != null) {
            jetpackTimer.cancel();
            jetpackTimer = null;
        }
    }

    public void resetPlayerState() {
        left = right = up = down = jumping = jetpack = false;
        player.setJetpackActive(false);
        player.resetJumps();
        player.setVelocityY(0.0);
        player.setOnGround(true);
        if (jetpackTimer != null) {
            jetpackTimer.cancel();
            jetpackTimer = null;
        }
    }

    /** Tâche interne pour activer le jetpack après 500 ms (mode plateforme). */
    private class JetpackTask extends TimerTask {
        @Override
        public void run() {
            jetpack = true;
            player.setJetpackActive(true);
        }
    }
}
fin fichier ./src/controller/GameController.java





début fichier ./src/Game.java
package src;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;

import java.util.List;
import java.util.Arrays;
import java.util.function.Function;

import src.levels.Level1;
import src.levels.SpaceshipLevel;
import src.levels.Level2;
import src.levels.Level3;
import src.levels.Level;

import src.controller.GameController;
import src.levels.Level;
import src.levels.Level1;
import src.model.Player;
import src.view.GameView;

public class Game extends Application {
    // Taille de base (800×600), utilisée comme taille initiale.
    private static final int WIDTH = 800;
    private static final int HEIGHT = 600;

    private Stage primaryStage;
    private Player player;
    private GameController controller;

    // Liste de "fabriques" de niveaux, dans l'ordre de jeu
    private List<Function<Player, Level>> levelSuppliers;
    private int currentLevelIndex = 0;

    @Override
    public void start(Stage primaryStage) {
        this.primaryStage = primaryStage;
        this.player = new Player(100, 500);

        // Initialise la liste de niveaux
        levelSuppliers = Arrays.asList(
            //Level3::new,
            Level1::new,
            SpaceshipLevel::new,
            Level2::new,
            Level3::new
        );

        primaryStage.setTitle("Steampunk Adventure");

        // Maximiser la fenêtre sans passer en plein écran
        primaryStage.setMaximized(true);

        // Charge le premier niveau
        loadCurrentLevel();

        primaryStage.show();
    }


    // --- Méthode utilitaire à ajouter ---
    private void loadCurrentLevel() {
        // Crée l’instance du niveau en fonction de currentLevelIndex
        Level lvl = levelSuppliers.get(currentLevelIndex).apply(player);
        loadLevel(lvl);
    }


    /**
     * Charge un niveau et met en place la scène avec un Canvas redimensionnable.
     * Arrête la boucle de jeu précédente si elle existe.
     */
    // --- Méthode déjà existante qui pose la scène ---
    public void loadLevel(Level level) {
        if (controller != null) {
            controller.stopGameLoop();
        }

        Pane root = new Pane();
        Canvas canvas = new Canvas(WIDTH, HEIGHT);
        canvas.widthProperty().bind(root.widthProperty());
        canvas.heightProperty().bind(root.heightProperty());
        root.getChildren().add(canvas);

        GraphicsContext gc = canvas.getGraphicsContext2D();
        GameView view = new GameView(gc);

        // Ici, on crée un NOUVEAU controller pour le nouveau niveau
        controller = new GameController(
            player,
            level.getPlatforms(),
            level.getEnemies(),
            level.getDecorations(),
            view,
            this,
            level
        );

        Scene scene = new Scene(root, WIDTH, HEIGHT);
        controller.handleInput(scene);

        primaryStage.setScene(scene);
        primaryStage.setResizable(true);
        controller.startGameLoop();
    }

    /**
     * Passe au niveau suivant dans la liste levelSuppliers.
     */
    public void nextLevel() {
        // Réinitialise l'état et la position du joueur.
        controller.resetPlayerState();
        player.setX(100);
        player.setY(500);

        if (currentLevelIndex < levelSuppliers.size() - 1) {
            currentLevelIndex++;
            loadCurrentLevel();
        } else {
            System.out.println("Vous avez terminé le jeu !");
            controller.stopGameLoop();
            // TODO : afficher un écran de victoire
        }
    }

    /**
     * Charge le niveau vaisseau, accessible depuis Level1.
     */
    public void loadSpaceshipLevel() {
        // Réinitialise l'état et la position du joueur.
        controller.resetPlayerState();
        player.setX(100);
        player.setY(500);

        loadLevel(new src.levels.SpaceshipLevel(player));
    }

    public static void main(String[] args) {
        launch(args);
    }
}
fin fichier ./src/Game.java





début fichier ./src/levels/Level1.java
package src.levels;

import javafx.scene.image.Image;
import src.model.Player;
import src.model.Platform;
import src.model.Decoration;
import src.model.platforms.SteelPlatform;
import src.model.platforms.GroundPlatform;
import src.model.platforms.BrickPlatform;
import src.model.Enemy;

public class Level1 extends Level {

    public Level1(Player player) {
        super(player);
    }

    @Override
    protected void initialize() {
        // Arrière-plan
        setBackgroundImage("file:../textures/background temporaire1.png");

        // ----------------------------------------------
        // 1) Ajouter un sol répété sur la largeur du niveau
        // ----------------------------------------------
        double levelWidth = 3000;    // Largeur totale du niveau
        Image groundTex = new Image("file:../textures/sol.png");
        double tileW = groundTex.getWidth();
        double tileH = groundTex.getHeight();
        double groundY = 600 - tileH;
        for (double x = 0; x < levelWidth; x += tileW) {
            platforms.add(new GroundPlatform(x, groundY, groundTex));
        }

        // ----------------------------------------------
        // 2) Tes autres plateformes en acier
        // ----------------------------------------------
        platforms.add(new SteelPlatform(200, groundY - 100));
        platforms.add(new SteelPlatform(1000, groundY - 100));
        platforms.add(new SteelPlatform(1000, 400));
        platforms.add(new SteelPlatform(0, groundY - 300));
        platforms.add(new SteelPlatform(500, groundY - 450));

        // ----------------------------------------------
        // 3) Ennemis
        // ----------------------------------------------
        enemies.add(new Enemy(650, groundY - 300, 50, 50, 2, 600, 800));
        enemies.add(new Enemy(1200, groundY - 50, 50, 50, 2, 1100, 1300));

        // 4) Décoration : un lampadaire dans le décor
        Image lamp = new Image("file:../textures/lampadaire 1.png");
        double lampH = lamp.getHeight();
        decorations.add(new Decoration(1200, groundY - lampH - 300, lamp));
    }

}fin fichier ./src/levels/Level1.java





début fichier ./src/levels/Level2.java
package src.levels;

import src.model.Player;
import src.model.platforms.CopperPlatform;
import src.model.platforms.FragilePlatform;
import javafx.scene.image.Image;
import src.model.platforms.GroundPlatform;
import src.model.Enemy;

public class Level2 extends Level {

    public Level2(Player player) {
        super(player);
    }

    @Override
    protected void initialize() {
        setBackgroundImage("file:../textures/background_level2.png");

        double levelWidth = 3000;
        Image groundTex = new Image("file:../textures/sol brique.png");
        double tileW = groundTex.getWidth();
        double tileH = groundTex.getHeight();
        double groundY = 600 - tileH;
        for (double x = 0; x < levelWidth; x += tileW) {
            platforms.add(new GroundPlatform(x, groundY, groundTex));
        }

        platforms.add(new FragilePlatform(100, groundY - 300)); // Première plateforme cassée
        platforms.add(new CopperPlatform(400, groundY - 250));
        platforms.add(new CopperPlatform(700, groundY - 300));
        platforms.add(new CopperPlatform(200, groundY - 350));
        platforms.add(new CopperPlatform(400, groundY - 350));

        // Ennemis
        enemies.add(new Enemy(450, 230, 50, 50, 2, 400, 600));
        enemies.add(new Enemy(800, 230, 50, 50, 2, 700, 900));
    }
}
fin fichier ./src/levels/Level2.java





début fichier ./src/levels/Level3.java
package src.levels;

import javafx.scene.image.Image;

import src.model.Player;
import src.model.Decoration;
import src.model.platforms.GroundPlatform;
import src.model.platforms.BrickPlatform;

public class Level3 extends Level {

    public Level3(Player player) {
        super(player);
    }

    @Override
    protected void initialize() {
        // Arrière-plan principal
        setBackgroundImage("file:../textures/background_level3.png");

        // 1) Sol en briques sur toute la largeur
        double levelWidth = 3000;
        Image groundTex = new Image("file:../textures/sol brique.png");
        double tileW = groundTex.getWidth();
        double tileH = groundTex.getHeight();
        double groundY = 600 - tileH;
        for (double x = 0; x < levelWidth; x += tileW) {
            platforms.add(new GroundPlatform(x, groundY, groundTex));
        }

        // 2) Plateformes en briques
        platforms.add(new BrickPlatform(200, groundY - 100));
        platforms.add(new BrickPlatform(200, groundY - 200));
        platforms.add(new BrickPlatform(1000, groundY - 100));
        platforms.add(new BrickPlatform(1000, groundY - 200));
        platforms.add(new BrickPlatform(1200, groundY - 300));

        // 3) Décoration : un lampadaire dans le décor
        Image lamp = new Image("file:../textures/lampadaire 1.png");
        double lampH = lamp.getHeight();
        decorations.add(new Decoration(1200, groundY - lampH - 300, lamp));
    }
}fin fichier ./src/levels/Level3.java





début fichier ./src/levels/Level.java
package src.levels;

import src.model.Player;
import src.model.Platform;
import src.model.Enemy;
import src.model.Decoration;

import javafx.scene.image.Image;
import java.util.List;
import java.util.ArrayList;

public abstract class Level {
    protected List<Platform> platforms;
    protected List<Enemy> enemies;
    protected List<Decoration> decorations;
    protected Player player;
    protected Image backgroundImage;

    public Level(Player player) {
        this.player      = player;
        this.platforms   = new ArrayList<>();
        this.enemies     = new ArrayList<>();
        this.decorations = new ArrayList<>();
        initialize();
    }

    protected abstract void initialize();

    public List<Platform> getPlatforms() {
        return platforms;
    }

    public List<Enemy> getEnemies() {
        return enemies;
    }

    public List<Decoration> getDecorations() {
        return decorations;
    }

    public Image getBackgroundImage() {
        return backgroundImage;
    }

    protected void setBackgroundImage(String imagePath) {
        this.backgroundImage = new Image(imagePath);
    }
}
fin fichier ./src/levels/Level.java





début fichier ./src/levels/SpaceshipLevel.java
package src.levels;

import src.model.Player;
import java.util.ArrayList;

public class SpaceshipLevel extends Level {

    public SpaceshipLevel(Player player) {
        super(player);
    }

    @Override
    protected void initialize() {
        // Pas de background (fond noir)
        // setBackgroundImage("file:../textures/black_background.png"); // si vous le souhaitez

        // Aucune plateforme ni ennemi
        this.platforms = new ArrayList<>();
        this.enemies   = new ArrayList<>();
    }
}
fin fichier ./src/levels/SpaceshipLevel.java





début fichier ./src/model/Decoration.java
package src.model;

import javafx.scene.image.Image;

public class Decoration {
    private double x, y, width, height;
    private Image texture;

    public Decoration(double x, double y, Image texture) {
        this.x = x;
        this.y = y;
        this.texture = texture;
        this.width = texture.getWidth();
        this.height = texture.getHeight();
    }

    public double getX()      { return x; }
    public double getY()      { return y; }
    public double getWidth()  { return width; }
    public double getHeight() { return height; }
    public Image getTexture() { return texture; }
}
fin fichier ./src/model/Decoration.java





début fichier ./src/model/Enemy.java
package src.model;

public class Enemy {
    private double x, y, width, height, speed;
    private double leftBound, rightBound;
    private boolean movingRight = true;

    public Enemy(double x, double y, double width, double height, double speed, double leftBound, double rightBound) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.speed = speed * 60;
        this.leftBound = leftBound;
        this.rightBound = rightBound;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    /** @param deltaSec  temps écoulé (s) */
    /**
 * @param deltaSec  temps écoulé (s) depuis la dernière frame
 */
    public void update(double deltaSec) {
        double move = speed * deltaSec;
        if (movingRight) {
            x += move;
            if (x >= rightBound) movingRight = false;
        } else {
            x -= move;
            if (x <= leftBound) movingRight = true;
        }
    }


}fin fichier ./src/model/Enemy.java





début fichier ./src/model/Platform.java
package src.model;

import javafx.scene.image.Image;

public abstract class Platform {
    protected double x, y, width, height;
    protected Image texture;

    public Platform(double x, double y, Image texture) {
        this.x = x;
        this.y = y;
        this.texture = texture;

        // Dimensions initiales basées sur la taille d'origine de la texture
        this.width = texture.getWidth();
        this.height = texture.getHeight();
    }

    public double getX()      { return x; }
    public double getY()      { return y; }
    public double getWidth()  { return width; }
    public double getHeight() { return height; }
    public Image getTexture() { return texture; }
}
fin fichier ./src/model/Platform.java





début fichier ./src/model/platforms/BrickPlatform.java
package src.model.platforms;

import javafx.scene.image.Image;
import src.model.Platform;

public class BrickPlatform extends Platform {

    public BrickPlatform(double x, double y) {
        super(x, y, new Image("file:../textures/plateforme brique.png"));
    }
}
fin fichier ./src/model/platforms/BrickPlatform.java





début fichier ./src/model/platforms/CopperPlatform.java
package src.model.platforms;

import javafx.scene.image.Image;
import src.model.Platform;

public class CopperPlatform extends Platform {

    public CopperPlatform(double x, double y) {
        super(x, y, new Image("file:../textures/plateforme cuivre.png"));
    }
}fin fichier ./src/model/platforms/CopperPlatform.java





début fichier ./src/model/platforms/FragilePlatform.java
package src.model.platforms;

import javafx.scene.image.Image;
import src.model.Platform;
import src.model.Player;

public class FragilePlatform extends Platform {
    private int steps = 0;
    private static final int MAX_STEPS = 2;
    private Image fragileTexture;
    private boolean playerWasOn = false;

    public FragilePlatform(double x, double y) {
        super(x, y, new Image("file:../textures/plateforme cuivre.png"));
        this.fragileTexture = new Image("file:../textures/plateforme_fragile.png");
    }

    /**
     * Retourne true si la plateforme est brisée (après 2 atterrissages).
     */
    public boolean isBroken() {
        return steps >= MAX_STEPS;
    }

    /**
     * Appelée lorsque le joueur atterrit sur la plateforme.
     * - 1er atterrissage => change la texture en "fissurée"
     * - 2e atterrissage => steps = 2 => isBroken() = true => la plateforme sera retirée.
     */
    public void step(Player player) {
        // On incrémente steps UNE SEULE FOIS par "atterrissage"
        if (!playerWasOn) {
            steps++;
            if (steps == 1) {
                this.texture = fragileTexture; // devient fissurée
            }
            playerWasOn = true;
            System.out.println("Steps: " + steps + " / " + MAX_STEPS);
        }
    }

    /**
     * Remet playerWasOn à false dès que le joueur n'est plus sur la plateforme.
     * Ainsi, la prochaine fois qu'il atterrit, on incrémente steps à nouveau.
     */
    public void resetStep(Player player) {
        if (!player.intersects(this)) {
            playerWasOn = false;
        }
    }
}
fin fichier ./src/model/platforms/FragilePlatform.java





début fichier ./src/model/platforms/GroundPlatform.java
package src.model.platforms;

import javafx.scene.image.Image;
import src.model.Platform;

public class GroundPlatform extends Platform {
    public GroundPlatform(double x, double y, Image texture) {
        super(x, y, texture);
    }
}
fin fichier ./src/model/platforms/GroundPlatform.java





début fichier ./src/model/platforms/SteelPlatform.java
package src.model.platforms;

import javafx.scene.image.Image;
import src.model.Platform;

public class SteelPlatform extends Platform {

    public SteelPlatform(double x, double y) {
        super(x, y, new Image("file:../textures/plateforme_acier_1.png"));

        if (this.texture.isError()) {
            System.err.println("Error loading SteelPlatform texture.");
        }

        // Facteur de réduction (ajuste si tu veux plus petit/grand)
        double scaleFactor = 0.3;

        // On réduit la bounding box (collision + affichage) à 30% de la taille initiale
        this.width  = this.width  * scaleFactor;
        this.height = this.height * scaleFactor;

        // On ne modifie pas this.y, donc le "haut" reste à y
        // (Si tu veux garder le bas au même endroit, voir plus bas *)

        System.out.println("[SteelPlatform] new bounding box => x=" + this.x
            + ", y=" + this.y + ", w=" + this.width + ", h=" + this.height);
    }
}
fin fichier ./src/model/platforms/SteelPlatform.java





début fichier ./src/model/Player.java
package src.model;

import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;

/**
 * Classe Player : gère la position, la vitesse, l'état (walking, jetpack, etc.)
 */
public class Player {
    private DoubleProperty x = new SimpleDoubleProperty();
    private DoubleProperty y = new SimpleDoubleProperty();
    private double width = 50;
    private double height = 50;
    public double velocityY = 0;
    public boolean onGround = false;
    private int jumps = 0;
    private static final int MAX_JUMPS = 2;
    private double speed = 180.0;
    private boolean jetpackActive = false;
    private boolean walking = false;

    // Propriété indiquant la direction : true = face à droite, false = face à gauche
    private boolean facingRight = true;

    public Player(double x, double y) {
        this.x.set(x);
        this.y.set(y);
    }

    public double getX() { return x.get(); }
    public void setX(double x) { this.x.set(x); }
    public DoubleProperty xProperty() { return x; }

    public double getY() { return y.get(); }
    public void setY(double y) { this.y.set(y); }
    public DoubleProperty yProperty() { return y; }

    public double getWidth() { return width; }
    public double getHeight() { return height; }

    public void move(double dx, double dy) {
        setX(getX() + dx);
        setY(getY() + dy);
        walking = (dx != 0);
    }

    public boolean isWalking() { return walking; }
    public void stopWalking() { walking = false; }

    public boolean intersects(Platform platform) {
        /*System.out.println("[DEBUG] Player intersects() -> "
            + "Player: x=" + getX() + ", y=" + getY()
            + ", w=" + getWidth() + ", h=" + getHeight()
            + " | Platform: x=" + platform.getX()
            + ", y=" + platform.getY()
            + ", w=" + platform.getWidth()
            + ", h=" + platform.getHeight());*/
        return getX() < platform.getX() + platform.getWidth()
            && getX() + getWidth() > platform.getX()
            && getY() < platform.getY() + platform.getHeight()
            && getY() + getHeight() > platform.getY();
    }

    public boolean intersects(Enemy enemy) {
        return getX() < enemy.getX() + enemy.getWidth()
            && getX() + getWidth() > enemy.getX()
            && getY() < enemy.getY() + enemy.getHeight()
            && getY() + getHeight() > enemy.getY();
    }

    public boolean landsOn(Enemy enemy) {
        return getX() < enemy.getX() + enemy.getWidth()
            && getX() + getWidth() > enemy.getX()
            && getY() + getHeight() >= enemy.getY()
            && getY() + getHeight() <= enemy.getY() + enemy.getHeight() / 2
            && velocityY > 0;
    }

    public int getJumps() { return jumps; }
    public void incrementJumps() { jumps++; }
    public void resetJumps() { jumps = 0; }
    public boolean canJump() { return jumps < MAX_JUMPS; }
    public double getSpeed() { return speed; }
    public void setSpeed(double speed) { this.speed = speed; }
    public boolean isJetpackActive() { return jetpackActive; }
    public void setJetpackActive(boolean jetpackActive) { this.jetpackActive = jetpackActive; }
    public void setVelocityY(double velocityY) { this.velocityY = velocityY; }
    public void setOnGround(boolean onGround) { this.onGround = onGround; }

    // Accesseurs pour la direction du joueur
    public boolean isFacingRight() {
        return facingRight;
    }

    public void setFacingRight(boolean facingRight) {
        this.facingRight = facingRight;
    }
}
fin fichier ./src/model/Player.java





début fichier ./src/model/Projectile.java
package src.model;

/**
 * Un projectile tiré par le vaisseau.
 */
public class Projectile {
    private double x, y;
    private static final double WIDTH  = 10;
    private static final double HEIGHT = 4;
    private static final double SPEED  = 360.0;
    private final boolean toRight;

    public Projectile(double x, double y, boolean toRight) {
        this.x       = x;
        this.y       = y;
        this.toRight = toRight;
    }

    /** Avance le projectile d’une frame. */
    /** @param deltaSec  temps écoulé (s) */
    public void update(double deltaSec) {
        x += (toRight ? 1 : -1) * SPEED * deltaSec;
    }


    /** Indique si le projectile est hors limites du niveau. */
    public boolean isOutOfBounds(double levelWidth) {
        return x + WIDTH < 0 || x > levelWidth;
    }

    /** Collision AABB basique avec un ennemi. */
    public boolean intersects(Enemy e) {
        return x < e.getX() + e.getWidth()
            && x + WIDTH  > e.getX()
            && y < e.getY() + e.getHeight()
            && y + HEIGHT > e.getY();
    }

    // Getters
    public double getX()      { return x; }
    public double getY()      { return y; }
    public double getWidth()  { return WIDTH; }
    public double getHeight() { return HEIGHT; }
}
fin fichier ./src/model/Projectile.java





début fichier ./src/test/SpaceshipTest.java
package test;

import javafx.animation.AnimationTimer;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.scene.input.KeyCode;

/**
 * Exemple minimal : un "vaisseau" (cercle) qui se déplace
 * librement avec les flèches. Aucune gravité, aucune collision.
 */
public class SpaceshipTest extends Application {

    private double x = 100;   // Position initiale du "vaisseau"
    private double y = 300;
    private double speed = 3; // Vitesse de déplacement

    private boolean up, down, left, right;

    @Override
    public void start(Stage primaryStage) {
        Canvas canvas = new Canvas(800, 600);
        GraphicsContext gc = canvas.getGraphicsContext2D();

        StackPane root = new StackPane(canvas);
        Scene scene = new Scene(root, 800, 600);

        // Gestion des touches
        scene.setOnKeyPressed(e -> {
            if (e.getCode() == KeyCode.UP)    up    = true;
            if (e.getCode() == KeyCode.DOWN)  down  = true;
            if (e.getCode() == KeyCode.LEFT)  left  = true;
            if (e.getCode() == KeyCode.RIGHT) right = true;
        });
        scene.setOnKeyReleased(e -> {
            if (e.getCode() == KeyCode.UP)    up    = false;
            if (e.getCode() == KeyCode.DOWN)  down  = false;
            if (e.getCode() == KeyCode.LEFT)  left  = false;
            if (e.getCode() == KeyCode.RIGHT) right = false;
        });

        primaryStage.setTitle("Spaceship Test");
        primaryStage.setScene(scene);
        primaryStage.show();

        // Boucle de jeu : ~60 fps
        AnimationTimer timer = new AnimationTimer() {
            @Override
            public void handle(long now) {
                update();
                draw(gc);
            }
        };
        timer.start();
    }

    /**
     * Met à jour la position du "vaisseau".
     */
    private void update() {
        if (up)    y -= speed;
        if (down)  y += speed;
        if (left)  x -= speed;
        if (right) x += speed;
    }

    /**
     * Dessine la scène : efface l'écran et dessine un cercle.
     */
    private void draw(GraphicsContext gc) {
        gc.clearRect(0, 0, 800, 600);

        gc.setFill(Color.BLACK);
        gc.fillRect(0, 0, 800, 600);

        gc.setFill(Color.WHITE);
        gc.setFont(Font.font(18));
        gc.fillText("Use arrow keys to move the spaceship.\nX=" + x + ", Y=" + y, 20, 30);

        // Dessine un cercle comme "vaisseau"
        gc.setFill(Color.YELLOW);
        gc.fillOval(x, y, 40, 40);
    }

    public static void main(String[] args) {
        launch(args);
    }
}
fin fichier ./src/test/SpaceshipTest.java





début fichier ./src/view/GameView.java
package src.view;

import javafx.application.Platform;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.scene.CacheHint;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.image.Image;
import javafx.scene.image.WritableImage;
import javafx.scene.paint.Color;

import java.util.List;
import java.util.concurrent.CountDownLatch;

public class GameView {
    private final DoubleProperty cameraX = new SimpleDoubleProperty(0);
    private final DoubleProperty cameraY = new SimpleDoubleProperty(0);
    private final GraphicsContext gc;

    // Cache pour le background redimensionné
    private Image cachedBackground = null;
    private double cachedWidth = 0, cachedHeight = 0;

    // ------------------------------------------------------------
    // Engrenage
    // ------------------------------------------------------------
    private Image gearSpriteSheet;
    private int gearFrameIndex = 0;
    private int gearFrameCount = 0;
    private int gearFrameWidth = 0;
    private int gearFrameHeight = 0;
    private long lastGearFrameTime = 0;
    private final long gearFrameDuration = 50_000_000; // 50 ms

    // ------------------------------------------------------------
    // Joueur Idle
    // ------------------------------------------------------------
    private Image playerIdleSheet;
    private int idleFrameIndex = 0;
    private int idleFrameCount = 0;
    private int idleFrameWidth = 0;
    private int idleFrameHeight = 0;
    private long lastIdleFrameTime = 0;
    private final long idleFrameDuration = 100_000_000; // 100 ms

    // ------------------------------------------------------------
    // Joueur Walk
    // ------------------------------------------------------------
    private Image playerWalkSheet;
    private int walkFrameIndex = 0;
    private int walkFrameCount = 0;
    private int walkFrameWidth = 0;
    private int walkFrameHeight = 0;
    private long lastWalkFrameTime = 0;
    private final long walkFrameDuration = 100_000_000; // 100 ms

    // ------------------------------------------------------------
    // Joueur Jump
    // ------------------------------------------------------------
    private Image playerJumpSheet;
    private int jumpFrameIndex = 0;
    private int jumpFrameCount = 0;
    private int jumpFrameWidth = 0;
    private int jumpFrameHeight = 0;
    private long lastJumpFrameTime = 0;
    private final long jumpFrameDuration = 100_000_000; // 100 ms

    // ------------------------------------------------------------
    // Sprite du vaisseau
    // ------------------------------------------------------------
    private Image spaceshipImage;
    private final double playerOffsetY = 50;

    public GameView(GraphicsContext gc) {
        this.gc = gc;
        Canvas canvas = gc.getCanvas();
        canvas.setCache(true);
        canvas.setCacheHint(CacheHint.SPEED);

        try {
            // Engrenage
            gearSpriteSheet = new Image("file:../textures/engrenage_animation-Sheet.png");
            if (!gearSpriteSheet.isError()) {
                gearFrameHeight = (int) gearSpriteSheet.getHeight();
                gearFrameWidth  = gearFrameHeight;
                if (gearFrameWidth != 0) {
                    gearFrameCount = (int) (gearSpriteSheet.getWidth() / gearFrameWidth);
                }
            }

            // Joueur Idle
            playerIdleSheet = new Image("file:../textures/static wrench-Sheet.png");
            if (!playerIdleSheet.isError()) {
                idleFrameHeight = (int) playerIdleSheet.getHeight();
                idleFrameWidth  = idleFrameHeight;
                if (idleFrameWidth != 0) {
                    idleFrameCount = (int) (playerIdleSheet.getWidth() / idleFrameWidth);
                }
            }

            // Joueur Walk
            playerWalkSheet = new Image("file:../textures/sprite sheet wrench walking.png");
            if (!playerWalkSheet.isError()) {
                walkFrameHeight = (int) playerWalkSheet.getHeight();
                walkFrameWidth  = walkFrameHeight;
                if (walkFrameWidth != 0) {
                    walkFrameCount = (int) (playerWalkSheet.getWidth() / walkFrameWidth);
                }
            }

            // Joueur Jump
            playerJumpSheet = new Image("file:../textures/jump2 wrench-Sheet.png");
            if (!playerJumpSheet.isError()) {
                jumpFrameHeight = (int) playerJumpSheet.getHeight();
                jumpFrameWidth  = jumpFrameHeight;
                if (jumpFrameWidth != 0) {
                    jumpFrameCount = (int) (playerJumpSheet.getWidth() / jumpFrameWidth);
                }
            }

            // Sprite vaisseau
            spaceshipImage = new Image("file:../textures/dirigeable v1.png");
        } catch (Exception e) {
            System.err.println("Exception loading images: " + e.getMessage());
        }
    }

    /**
     * Retourne une version redimensionnée du background (thread-safe).
     */
    private Image getScaledBackground(Image background, double width, double height) {
        if (Platform.isFxApplicationThread()) {
            return createScaledBackground(background, width, height);
        } else {
            final Image[] result = new Image[1];
            final CountDownLatch latch = new CountDownLatch(1);
            Platform.runLater(() -> {
                result[0] = createScaledBackground(background, width, height);
                latch.countDown();
            });
            try {
                latch.await();
            } catch (InterruptedException ignored) {}
            return result[0];
        }
    }

    private Image createScaledBackground(Image background, double width, double height) {
        Canvas temp = new Canvas(width, height);
        GraphicsContext gc2 = temp.getGraphicsContext2D();
        gc2.drawImage(background, 0, 0, width, height);
        WritableImage wi = new WritableImage((int) width, (int) height);
        temp.snapshot(null, wi);
        return wi;
    }

    /**
     * Dessine la frame complète, avec décorations, plateformes, ennemis et projectiles.
     */
    public void draw(
        Image background,
        double playerX, double playerY,
        double playerW, double playerH,
        boolean isWalking, boolean facingRight,
        boolean isJumping, boolean spaceshipMode,
        List<Image> decorationImages,
        List<Double[]> decorationPositions,
        List<Image> platformImages,
        List<Double[]> platformPositions,
        List<Double[]> enemyPositions,
        List<Double[]> projectilePositions
    ) {
        double cw = gc.getCanvas().getWidth();
        double ch = gc.getCanvas().getHeight();

        // Fond noir
        gc.setFill(Color.BLACK);
        gc.fillRect(0, 0, cw, ch);

        // Background mis à l’échelle + cache
        if (background != null) {
            if (cachedBackground == null || cachedWidth != cw || cachedHeight != ch) {
                cachedBackground = getScaledBackground(background, cw, ch);
                cachedWidth = cw; cachedHeight = ch;
            }
            gc.drawImage(cachedBackground, 0, 0);
        }

        // Engrenage
        if (gearSpriteSheet != null && gearFrameWidth > 0) {
            long now = System.nanoTime();
            if (now - lastGearFrameTime >= gearFrameDuration) {
                gearFrameIndex = (gearFrameIndex + 1) % gearFrameCount;
                lastGearFrameTime = now;
            }
            int sx = gearFrameIndex * gearFrameWidth;
            gc.drawImage(gearSpriteSheet,
                         sx, 0, gearFrameWidth, gearFrameHeight,
                         0, 0, gearFrameWidth, gearFrameHeight);
        }

        // 1) Décorations (lampadaire, etc.)
        for (int i = 0; i < decorationImages.size(); i++) {
            Image img = decorationImages.get(i);
            Double[] pos = decorationPositions.get(i);
            double dx = pos[0] - cameraX.get();
            double dy = pos[1] - cameraY.get();
            double dw = pos[2], dh = pos[3];
            if (img != null) {
                gc.drawImage(img, dx, dy, dw, dh);
            }
        }

        // JOUEUR ou VAISSEAU
        double drawX = playerX - cameraX.get();
        double drawY = playerY - cameraY.get() - playerOffsetY;
        if (spaceshipMode && spaceshipImage != null) {
            double imageW = spaceshipImage.getWidth();
            double imageH = spaceshipImage.getHeight();
            double targetH = playerH * 2.0;
            double targetW = targetH * (imageW / imageH);

            if (facingRight) {
                gc.drawImage(spaceshipImage,
                             drawX, drawY,
                             targetW, targetH);
            } else {
                gc.save();
                gc.translate(drawX + targetW, drawY);
                gc.scale(-1, 1);
                gc.drawImage(spaceshipImage,
                             0, 0,
                             targetW, targetH);
                gc.restore();
            }
        } else if (isJumping && playerJumpSheet != null && jumpFrameWidth > 0) {
            long now = System.nanoTime();
            if (now - lastJumpFrameTime >= jumpFrameDuration) {
                jumpFrameIndex = (jumpFrameIndex + 1) % jumpFrameCount;
                lastJumpFrameTime = now;
            }
            int sx = jumpFrameIndex * jumpFrameWidth;
            if (facingRight) {
                gc.drawImage(playerJumpSheet,
                             sx, 0, jumpFrameWidth, jumpFrameHeight,
                             drawX, drawY, playerW * 2, playerH * 2);
            } else {
                gc.save();
                gc.translate(drawX + playerW * 2, drawY);
                gc.scale(-1, 1);
                gc.drawImage(playerJumpSheet,
                             sx, 0, jumpFrameWidth, jumpFrameHeight,
                             0, 0, playerW * 2, playerH * 2);
                gc.restore();
            }
        } else if (isWalking && playerWalkSheet != null && walkFrameWidth > 0) {
            long now = System.nanoTime();
            if (now - lastWalkFrameTime >= walkFrameDuration) {
                walkFrameIndex = (walkFrameIndex + 1) % walkFrameCount;
                lastWalkFrameTime = now;
            }
            int sx = walkFrameIndex * walkFrameWidth;
            if (facingRight) {
                gc.drawImage(playerWalkSheet,
                             sx, 0, walkFrameWidth, walkFrameHeight,
                             drawX, drawY, playerW * 2, playerH * 2);
            } else {
                gc.save();
                gc.translate(drawX + playerW * 2, drawY);
                gc.scale(-1, 1);
                gc.drawImage(playerWalkSheet,
                             sx, 0, walkFrameWidth, walkFrameHeight,
                             0, 0, playerW * 2, playerH * 2);
                gc.restore();
            }
        } else if (playerIdleSheet != null && idleFrameWidth > 0) {
            long now = System.nanoTime();
            if (now - lastIdleFrameTime >= idleFrameDuration) {
                idleFrameIndex = (idleFrameIndex + 1) % idleFrameCount;
                lastIdleFrameTime = now;
            }
            int sx = idleFrameIndex * idleFrameWidth;
            if (facingRight) {
                gc.drawImage(playerIdleSheet,
                             sx, 0, idleFrameWidth, idleFrameHeight,
                             drawX, drawY, playerW * 2, playerH * 2);
            } else {
                gc.save();
                gc.translate(drawX + playerW * 2, drawY);
                gc.scale(-1, 1);
                gc.drawImage(playerIdleSheet,
                             sx, 0, idleFrameWidth, idleFrameHeight,
                             0, 0, playerW * 2, playerH * 2);
                gc.restore();
            }
        }

        // 3) Plateformes
        for (int i = 0; i < platformImages.size(); i++) {
            Image img = platformImages.get(i);
            Double[] pos = platformPositions.get(i);
            double px = pos[0] - cameraX.get();
            double py = pos[1] - cameraY.get();
            double pw = pos[2], ph = pos[3];
            if (img != null) {
                gc.drawImage(img, px, py, pw, ph);
            } else {
                gc.setFill(Color.BLUE);
                gc.fillRect(px, py, pw, ph);
            }
        }

        // 4) Ennemis
        gc.setFill(Color.GREEN);
        for (Double[] pos : enemyPositions) {
            double ex = pos[0] - cameraX.get();
            double ey = pos[1] - cameraY.get();
            double ew = pos[2], eh = pos[3];
            gc.fillRect(ex, ey, ew, eh);
        }

        // 5) Projectiles (mode vaisseau)
        if (spaceshipMode) {
            gc.setFill(Color.RED);
            for (Double[] pos : projectilePositions) {
                double px = pos[0] - cameraX.get();
                double py = pos[1] - cameraY.get();
                double pw = pos[2], ph = pos[3];
                gc.fillRect(px, py, pw, ph);
            }
        }
    }

    // Accesseurs pour la caméra et la taille du canvas
    public DoubleProperty cameraXProperty() { return cameraX; }
    public DoubleProperty cameraYProperty() { return cameraY; }
    public double getCanvasWidth()        { return gc.getCanvas().getWidth(); }
    public double getCanvasHeight()       { return gc.getCanvas().getHeight(); }
}
fin fichier ./src/view/GameView.java





