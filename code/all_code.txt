début fichier ./src/common/JsonReader.java
// code/src/common/JsonReader.java
package src.common;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.stream.Collectors;

import javafx.application.Platform;
import org.json.JSONObject;

public class JsonReader {
    public static JSONObject getJsonObjectContent(String resourcePath) {
        try (InputStream in = JsonReader.class
                 .getClassLoader()
                 .getResourceAsStream(resourcePath)) {
            if (in == null) {
                System.err.println("Ressource introuvable: " + resourcePath);
                Platform.exit();
                return null;
            }
            String json = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8))
                            .lines()
                            .collect(Collectors.joining("\n"));
            return new JSONObject(json);
        } catch (Exception e) {
            e.printStackTrace();
            Platform.exit();
            return null;
        }
    }
}
fin fichier ./src/common/JsonReader.java





début fichier ./src/controller/GameController.java
// src/controller/GameController.java
package src.controller;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import javafx.animation.AnimationTimer;
import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
import javafx.scene.image.Image;

import src.Game;
import src.levels.Level;
import src.levels.SpaceshipLevel;
import src.model.Player;
import src.model.Platform;
import src.model.Enemy;
import src.model.Boss;
import src.model.Projectile;
import src.model.Decoration;
import src.view.GameView;

public class GameController {
    private static final double GRAVITY = 1800.0;
    private static final double SHIP_SCROLL_SPEED = 200.0; // px/s

    // Flags de déplacement
    private boolean left, right, up, down, jumping, jetpack;

    private final Player player;
    private final List<Platform> platforms;
    private final List<Enemy> enemies;
    private final List<Decoration> decorations;
    private final List<Projectile> projectiles = new ArrayList<>();
    private final GameView view;
    private final Game game;
    private final Level level;

    private final double initialPlayerX, initialPlayerY;
    private Timer jetpackTimer;

    // Dimensions “logiques” du niveau
    private final double levelWidth  = 3000.0;
    private final double levelHeight = 600.0;

    // Caméra
    private double cameraX = 0.0, cameraY = 0.0;

    // Boucle JavaFX
    private AnimationTimer gameLoop;

    public GameController(Player player,
                          List<Platform> platforms,
                          List<Enemy> enemies,
                          List<Decoration> decorations,
                          GameView view,
                          Game game,
                          Level level) {
        this.player          = player;
        this.platforms       = platforms;
        this.enemies         = enemies;
        this.decorations     = decorations;
        this.view            = view;
        this.game            = game;
        this.level           = level;
        this.initialPlayerX  = player.getX();
        this.initialPlayerY  = player.getY();
    }

    /** Lie les touches aux flags, et gère tirs vs saut. */
    public void handleInput(Scene scene) {
        scene.setOnKeyPressed(e -> {
            if (e.getCode() == KeyCode.LEFT)  left  = true;
            if (e.getCode() == KeyCode.RIGHT) right = true;
            if (e.getCode() == KeyCode.UP)    up    = true;
            if (e.getCode() == KeyCode.DOWN)  down  = true;

            if (e.getCode() == KeyCode.SPACE) {
                if (level instanceof SpaceshipLevel) {
                    fireProjectile();
                } else {
                    jumping = true;
                    if (jetpackTimer == null) {
                        jetpackTimer = new Timer(true);
                        jetpackTimer.schedule(new JetpackTask(), 500L);
                    }
                }
            }
        });

        scene.setOnKeyReleased(e -> {
            if (e.getCode() == KeyCode.LEFT)  left  = false;
            if (e.getCode() == KeyCode.RIGHT) right = false;
            if (e.getCode() == KeyCode.UP)    up    = false;
            if (e.getCode() == KeyCode.DOWN)  down  = false;

            if (e.getCode() == KeyCode.SPACE && !(level instanceof SpaceshipLevel)) {
                jumping = false;
                jetpack = false;
                player.setJetpackActive(false);
                if (jetpackTimer != null) {
                    jetpackTimer.cancel();
                    jetpackTimer = null;
                }
            }
        });
    }

    /** Démarre la boucle via AnimationTimer. */
    public void startGameLoop() {
        gameLoop = new AnimationTimer() {
            private long lastTime = 0;
            @Override
            public void handle(long now) {
                if (lastTime == 0) {
                    lastTime = now;
                    return;
                }
                double deltaSec = (now - lastTime) / 1_000_000_000.0;
                update(deltaSec);
                lastTime = now;
            }
        };
        gameLoop.start();
    }

    /** Stoppe proprement la boucle en cours. */
    public void stopGameLoop() {
        if (gameLoop != null) {
            gameLoop.stop();
        }
    }

    /** Itération de la boucle (~60FPS). */
    private void update(double deltaSec) {
        boolean isShip = (level instanceof SpaceshipLevel);

        // dx selon input
        double dx    = 0.0;
        double speed = player.getSpeed() * 1.5; // px/s
        if (left)  { dx -= speed * deltaSec; player.setFacingRight(false); }
        if (right) { dx += speed * deltaSec; player.setFacingRight(true); }

        if (isShip) {
            // Mouvement du vaisseau en mode spaceship
            updateSpaceship(dx, deltaSec);
            updateProjectiles(deltaSec);

            // Défilement auto de la caméra
            cameraX += SHIP_SCROLL_SPEED * deltaSec;
            cameraX = Math.min(cameraX, levelWidth - view.getCanvasWidth());

            // Contrainte du joueur dans la zone visible
            double minX    = cameraX;
            double maxXpos = cameraX + view.getCanvasWidth() - player.getWidth();
            if (player.getX() < minX)    player.setX(minX);
            if (player.getX() > maxXpos) player.setX(maxXpos);

        } else {
            // Mode plateforme
            updatePlatform(dx, deltaSec);
        }

        // Passage de niveau automatique
        if (player.getX() > 1600.0) {
            javafx.application.Platform.runLater(game::nextLevel);
        }

        // Mise à jour caméra & rendu
        updateCamera(isShip);
        render(isShip);
    }

    /** Update en mode spaceship (déplacement libre). */
    private void updateSpaceship(double dx, double deltaSec) {
        double dy = 0.0;
        if (up)   dy -= player.getSpeed() * 1.5 * deltaSec;
        if (down) dy += player.getSpeed() * 1.5 * deltaSec;
        player.move(dx, dy);
    }

    /** Met à jour projectiles (mouvement + collisions). */
    private void updateProjectiles(double deltaSec) {
        Iterator<Projectile> pit = projectiles.iterator();
        while (pit.hasNext()) {
            Projectile p = pit.next();
            p.update(deltaSec);
            if (p.isOutOfBounds(levelWidth)) {
                pit.remove();
                continue;
            }
            Iterator<Enemy> eit = enemies.iterator();
            while (eit.hasNext()) {
                Enemy enemy = eit.next();
                if (p.intersects(enemy)) {
                    eit.remove();
                    pit.remove();
                    break;
                }
            }
        }
    }

    /** Tire un projectile (mode spaceship). */
    private void fireProjectile() {
        double offsetX = player.isFacingRight() ? player.getWidth() : -10;
        double px = player.getX() + offsetX;
        double py = player.getY() + player.getHeight() / 2.0;
        projectiles.add(new Projectile(px, py, player.isFacingRight()));
    }

    /** Update en mode plateforme (gravité + collisions). */
    private void updatePlatform(double dx, double deltaSec) {
        double oldY = player.getY();

        if (jumping && player.canJump() && !jetpack) {
            player.setVelocityY(-603.0);
            player.setOnGround(false);
            player.incrementJumps();
            jumping = false;
        }

        if (jetpack && player.isJetpackActive()) {
            player.setVelocityY(-300.0);
        } else {
            player.setVelocityY(player.velocityY + GRAVITY * deltaSec);
        }

        double dy = player.velocityY * deltaSec;
        player.move(dx, dy);

        handlePlatformCollisions(oldY);
        handleEnemies(deltaSec);

        if (player.getY() > levelHeight) {
            resetPlayerPosition();
        }
    }

    /**
     * Gère les collisions plateformes en s’assurant qu’on vient d’en haut,
     * puis supprime les plateformes fragiles cassées.
     */
    private void handlePlatformCollisions(double oldY) {
        // 1) Reset fragile platforms
        for (Platform p : platforms) {
            if (p instanceof src.model.platforms.FragilePlatform) {
                ((src.model.platforms.FragilePlatform) p).resetStep(player);
            }
        }

        // 2) Gestion de l’atterrissage
        for (Platform p : platforms) {
            double top    = p.getY();
            double botNow = player.getY() + player.getHeight();
            double botOld = oldY            + player.getHeight();

            if (player.intersects(p)
                && player.velocityY > 0
                && botOld <= top) {
                player.setY(top - player.getHeight());
                player.velocityY = 0;
                player.setOnGround(true);
                player.resetJumps();
                if (p instanceof src.model.platforms.FragilePlatform) {
                    src.model.platforms.FragilePlatform fp =
                        (src.model.platforms.FragilePlatform) p;
                    if (!fp.isBroken()) {
                        fp.step(player);
                    }
                }
            }
        }

        // 3) Suppression des plateformes fragiles désormais cassées
        platforms.removeIf(p ->
            p instanceof src.model.platforms.FragilePlatform
            && ((src.model.platforms.FragilePlatform) p).isBroken()
        );
    }

    /** Gère déplacement & collisions ennemis. */
    private void handleEnemies(double deltaSec) {
        List<Enemy> toRemove = new ArrayList<>();
        for (Enemy e : enemies) {
            e.update(deltaSec);
            if (player.landsOn(e)) {
                if (e instanceof Boss) {
                    Boss boss = (Boss) e;
                    boss.hit();
                    if (boss.isDead()) {
                        toRemove.add(boss);
                    }
                    player.setVelocityY(-600.0);
                } else {
                    toRemove.add(e);
                    player.setVelocityY(-600.0);
                }
            } else if (player.intersects(e)) {
                resetPlayerPosition();
            }
        }
        enemies.removeAll(toRemove);
    }

    /** Met à jour la caméra selon le mode. */
    private void updateCamera(boolean isShip) {
        double cw = view.getCanvasWidth();
        double ch = view.getCanvasHeight();

        if (!isShip) {
            double targetX = player.getX() - cw / 2.0;
            cameraX += 0.1 * (targetX - cameraX);
            cameraX = Math.max(0, Math.min(cameraX, levelWidth - cw));
        }

        if (isShip) {
            cameraY = 0;
        } else if (ch > levelHeight) {
            cameraY = levelHeight - ch;
        } else {
            double targetY = player.getY() - ch / 2.0;
            cameraY += 0.1 * (targetY - cameraY);
            cameraY = Math.max(0, Math.min(cameraY, levelHeight - ch));
        }

        view.cameraXProperty().set(cameraX);
        view.cameraYProperty().set(cameraY);
    }

    /** Dessine tout : décor, plateformes, ennemis, projectiles, joueur/vaisseau. */
    private void render(boolean isShip) {
        List<Image> decoImgs   = new ArrayList<>();
        List<Double[]> posDeco = new ArrayList<>();
        for (Decoration d : decorations) {
            decoImgs.add(d.getTexture());
            posDeco.add(new Double[]{d.getX(), d.getY(), d.getWidth(), d.getHeight()});
        }
        List<Image> platImgs   = new ArrayList<>();
        List<Double[]> posPl   = new ArrayList<>();
        for (Platform p : platforms) {
            platImgs.add(p.getTexture());
            posPl.add(new Double[]{p.getX(), p.getY(), p.getWidth(), p.getHeight()});
        }
        List<Double[]> posProj = new ArrayList<>();
        for (Projectile p : projectiles) {
            posProj.add(new Double[]{p.getX(), p.getY(), p.getWidth(), p.getHeight()});
        }

        boolean isJumping = !player.onGround;
        view.draw(
            level.getBackgroundImage(),
            player.getX(), player.getY(),
            player.getWidth(), player.getHeight(),
            player.isWalking(), player.isFacingRight(),
            isJumping,
            isShip,
            decoImgs, posDeco,
            platImgs, posPl,
            enemies,
            posProj
        );
    }

    /** Remet le joueur en position et état initiaux. */
    private void resetPlayerPosition() {
        player.setX(initialPlayerX);
        player.setY(initialPlayerY);
        player.velocityY    = 0;
        player.setOnGround(true);
        player.resetJumps();
        player.setJetpackActive(false);
        if (jetpackTimer != null) {
            jetpackTimer.cancel();
            jetpackTimer = null;
        }
    }

    /** Réinitialise uniquement les flags (sans arrêter la boucle). */
    public void resetPlayerState() {
        left = right = up = down = jumping = jetpack = false;
        player.setJetpackActive(false);
        player.resetJumps();
        player.setVelocityY(0);
        player.setOnGround(true);
        if (jetpackTimer != null) {
            jetpackTimer.cancel();
            jetpackTimer = null;
        }
    }

    /** TimerTask interne pour activer le jetpack après 500 ms. */
    private class JetpackTask extends TimerTask {
        @Override
        public void run() {
            jetpack = true;
            player.setJetpackActive(true);
        }
    }
}fin fichier ./src/controller/GameController.java





début fichier ./src/Game.java
// src/Game.java
package src;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;

import src.controller.GameController;
import src.levels.Level;
import src.levels.SpaceshipLevel;
import src.model.Player;
import src.view.GameView;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

public class Game extends Application {
    private static final int WIDTH  = 800;
    private static final int HEIGHT = 600;

    private Stage primaryStage;
    private Scene scene;
    private Pane root;
    private Canvas canvas;
    private Player player;
    private GameController controller;

    private List<Function<Player, Level>> levelSuppliers;
    private int currentLevelIndex = 0;

    @Override
    public void start(Stage primaryStage) {
        this.primaryStage = primaryStage;
        this.player = new Player(100, 500);

        root = new Pane();
        canvas = new Canvas(WIDTH, HEIGHT);
        canvas.widthProperty().bind(root.widthProperty());
        canvas.heightProperty().bind(root.heightProperty());
        root.getChildren().add(canvas);
        scene = new Scene(root, WIDTH, HEIGHT);

        primaryStage.setTitle("Steampunk Adventure");
        primaryStage.setScene(scene);
        primaryStage.setResizable(true);
        primaryStage.setMaximized(true);
        primaryStage.show();

        // Liste des noms de niveaux JSON
        List<String> levelNames = List.of("level1", "level2", "level3", "level4", "level5");
        levelSuppliers = new ArrayList<>();

        // Instancie Level(player, name) pour chaque JSON
        levelNames.forEach(name ->
            levelSuppliers.add(p -> new Level(p, name))
        );
        // Insère le niveau vaisseau après le premier
        levelSuppliers.add(1, SpaceshipLevel::new);

        loadCurrentLevel();
    }

    private void loadCurrentLevel() {
        Level lvl = levelSuppliers.get(currentLevelIndex).apply(player);

        if (controller != null) {
            controller.stopGameLoop();
        }

        GraphicsContext gc = canvas.getGraphicsContext2D();
        GameView view = new GameView(gc);

        controller = new GameController(
            player,
            lvl.getPlatforms(),
            lvl.getEnemies(),
            lvl.getDecorations(),
            view,
            this,
            lvl
        );

        controller.handleInput(scene);
        controller.startGameLoop();
    }

    public void nextLevel() {
        controller.resetPlayerState();
        player.setX(100);
        player.setY(500);

        if (currentLevelIndex < levelSuppliers.size() - 1) {
            currentLevelIndex++;
            loadCurrentLevel();
        } else {
            System.out.println("🎉 Vous avez terminé le jeu !");
            controller.stopGameLoop();
        }
    }

    public static void main(String[] args) {
        launch(args);
    }
}
fin fichier ./src/Game.java





début fichier ./src/levels/Level.java
// src/levels/Level.java
package src.levels;

import javafx.scene.image.Image;
import src.common.JsonReader;
import src.model.Platform;
import src.model.Enemy;
import src.model.Boss;
import src.model.Decoration;
import src.model.Player;
import src.model.platforms.FragilePlatform;

import org.json.JSONArray;
import org.json.JSONObject;

import java.util.List;
import java.util.ArrayList;

public class Level {
    protected List<Platform>   platforms;
    protected List<Enemy>      enemies;
    protected List<Decoration> decorations;
    protected Player           player;
    protected Image            backgroundImage;
    protected double           levelWidth;
    protected double           levelHeight;

    /** Constructeur codé en dur */
    public Level(Player player) {
        this.player      = player;
        this.platforms   = new ArrayList<>();
        this.enemies     = new ArrayList<>();
        this.decorations = new ArrayList<>();
        initialize();
    }

    /** Constructeur JSON */
    public Level(Player player, String levelName) {
        this.player      = player;
        this.platforms   = new ArrayList<>();
        this.enemies     = new ArrayList<>();
        this.decorations = new ArrayList<>();
        initialize(levelName);
    }

    /** À surcharger si code en dur */
    protected void initialize() {
        // vide par défaut
    }

    /** Initialise depuis JSON */
    protected void initialize(String levelName) {
        JSONObject L = JsonReader.getJsonObjectContent("levels/" + levelName + ".json");

        // 1) background + dimensions
        setBackgroundImage(L.getString("backgroundImage"));
        setLevelDimensions(L.getDouble("levelWidth"), L.getDouble("levelHeight"));

        // 2) plateformes
        JSONArray plats = L.getJSONArray("platforms");
        for (int i = 0; i < plats.length(); i++) {
            JSONObject p = plats.getJSONObject(i);
            String name = p.getString("name");
            double x     = p.getDouble("x");
            double y     = p.getDouble("y");
            if ("fragile".equals(name)) {
                platforms.add(new FragilePlatform(x, y));
            } else {
                platforms.add(new Platform(x, y, name));
            }
        }

        // 3) ennemis + boss
        JSONArray ens = L.getJSONArray("enemies");
        for (int i = 0; i < ens.length(); i++) {
            JSONObject e = ens.getJSONObject(i);
            double x           = e.getDouble("x");
            double y           = e.getDouble("y");
            double width       = e.getDouble("width");
            double height      = e.getDouble("height");
            double speed       = e.getDouble("speed");
            double patrolStart = e.getDouble("patrolStart");
            double patrolEnd   = e.getDouble("patrolEnd");
            if (e.optBoolean("boss", false)) {
                enemies.add(new Boss(x, y, width, height, speed, patrolStart, patrolEnd));
            } else {
                enemies.add(new Enemy(x, y, width, height, speed, patrolStart, patrolEnd));
            }
        }

        // 4) décorations
        if (L.has("decorations")) {
            for (Object o : L.getJSONArray("decorations")) {
                JSONObject d = (JSONObject) o;
                Image tex = new Image(d.getString("image"));
                decorations.add(new Decoration(d.getDouble("x"), d.getDouble("y"), tex));
            }
        }
    }

    // ——————————— Getters ———————————

    public List<Platform>   getPlatforms()       { return platforms;    }
    public List<Enemy>      getEnemies()         { return enemies;      }
    public List<Decoration> getDecorations()     { return decorations;  }
    public Image            getBackgroundImage() { return backgroundImage; }
    public double           getLevelWidth()      { return levelWidth;   }
    public double           getLevelHeight()     { return levelHeight;  }

    // ——————————— Helpers ———————————

    protected void setBackgroundImage(String path) {
        this.backgroundImage = new Image(path);
    }

    protected void setLevelDimensions(double w, double h) {
        this.levelWidth  = w;
        this.levelHeight = h;
    }
}
fin fichier ./src/levels/Level.java





début fichier ./src/levels/SpaceshipLevel.java
package src.levels;

import src.model.Player;
import java.util.ArrayList;

public class SpaceshipLevel extends Level {

    public SpaceshipLevel(Player player) {
        super(player);
    }

    @Override
    protected void initialize() {
        // Pas de background (fond noir)
        // setBackgroundImage("file:../textures/black_background.png"); // si vous le souhaitez

        // Aucune plateforme ni ennemi
        this.platforms = new ArrayList<>();
        this.enemies   = new ArrayList<>();
    }
}
fin fichier ./src/levels/SpaceshipLevel.java





début fichier ./src/model/Boss.java
package src.model;

public class Boss extends Enemy {
    private int hits = 0;
    private static final int MAX_HITS = 3;
    private double hitTimer = 0.0; // en secondes

    public Boss(double x, double y, double width, double height,
                double speed, double leftBound, double rightBound) {
        super(x, y, width, height, speed, leftBound, rightBound);
    }

    @Override
    public void update(double deltaSec) {
        super.update(deltaSec);
        if (hitTimer > 0) {
            hitTimer = Math.max(0, hitTimer - deltaSec);
        }
    }

    /** Appelée quand le joueur saute dessus */
    public void hit() {
        hits++;
        hitTimer = 0.2; // flash rouge pendant 0,2 s
    }

    /** True si le boss doit disparaître */
    public boolean isDead() {
        return hits >= MAX_HITS;
    }

    /** True si on est en plein flash rouge */
    public boolean isHit() {
        return hitTimer > 0;
    }
}
fin fichier ./src/model/Boss.java





début fichier ./src/model/Decoration.java
package src.model;

import javafx.scene.image.Image;

public class Decoration {
    private double x, y, width, height;
    private Image texture;

    public Decoration(double x, double y, Image texture) {
        this.x = x;
        this.y = y;
        this.texture = texture;
        this.width = texture.getWidth();
        this.height = texture.getHeight();
    }

    public double getX()      { return x; }
    public double getY()      { return y; }
    public double getWidth()  { return width; }
    public double getHeight() { return height; }
    public Image getTexture() { return texture; }
}
fin fichier ./src/model/Decoration.java





début fichier ./src/model/Enemy.java
package src.model;

public class Enemy {
    private double x, y, width, height, speed;
    private double leftBound, rightBound;
    private boolean movingRight = true;

    public Enemy(double x, double y, double width, double height, double speed, double leftBound, double rightBound) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.speed = speed * 60;
        this.leftBound = leftBound;
        this.rightBound = rightBound;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    /** @param deltaSec  temps écoulé (s) */
    /**
 * @param deltaSec  temps écoulé (s) depuis la dernière frame
 */
    public void update(double deltaSec) {
        double move = speed * deltaSec;
        if (movingRight) {
            x += move;
            if (x >= rightBound) movingRight = false;
        } else {
            x -= move;
            if (x <= leftBound) movingRight = true;
        }
    }


}fin fichier ./src/model/Enemy.java





début fichier ./src/model/Platform.java
package src.model;

import javafx.scene.image.Image;
import src.common.JsonReader;

import org.json.JSONObject;

public class Platform {
    protected static JSONObject platformsJson = JsonReader.getJsonObjectContent("platforms.json");
    protected double x, y, width, height;
    protected Image texture;

    public Platform(double x, double y, Image texture) {
        this.x = x;
        this.y = y;
        this.texture = texture;

        // Dimensions initiales basées sur la taille d'origine de la texture
        this.width = texture.getWidth();
        this.height = texture.getHeight();
    }


    public Platform(double x, double y, String platformName) {
        JSONObject platformJson = platformsJson.getJSONObject(platformName);
        this.x = x;
        this.y = y;
        this.texture = new Image(platformJson.getString("texture"));

        // Dimensions initiales basées sur la taille d'origine de la texture
        double scaleFactor = platformJson.getDouble("scaleFactor");
        this.width = texture.getWidth() * scaleFactor;
        this.height = texture.getHeight() * scaleFactor;
    }

    public double getX()      { return x; }
    public double getY()      { return y; }
    public double getWidth()  { return width; }
    public double getHeight() { return height; }
    public Image getTexture() { return texture; }
}
fin fichier ./src/model/Platform.java





début fichier ./src/model/platforms/FragilePlatform.java
package src.model.platforms;

import javafx.scene.image.Image;
import src.model.Platform;
import src.model.Player;

public class FragilePlatform extends Platform {
    private int steps = 0;
    private static final int MAX_STEPS = 2;
    private Image fragileTexture;
    private boolean playerWasOn = false;

    public FragilePlatform(double x, double y) {
        super(x, y, new Image("file:../textures/plateforme cuivre.png"));
        this.fragileTexture = new Image("file:../textures/plateforme_fragile.png");
    }

    /**
     * Retourne true si la plateforme est brisée (après 2 atterrissages).
     */
    public boolean isBroken() {
        return steps >= MAX_STEPS;
    }

    /**
     * Appelée lorsque le joueur atterrit sur la plateforme.
     * - 1er atterrissage => change la texture en "fissurée"
     * - 2e atterrissage => steps = 2 => isBroken() = true => la plateforme sera retirée.
     */
    public void step(Player player) {
        // On incrémente steps UNE SEULE FOIS par "atterrissage"
        if (!playerWasOn) {
            steps++;
            if (steps == 1) {
                this.texture = fragileTexture; // devient fissurée
            }
            playerWasOn = true;
            System.out.println("Steps: " + steps + " / " + MAX_STEPS);
        }
    }

    /**
     * Remet playerWasOn à false dès que le joueur n'est plus sur la plateforme.
     * Ainsi, la prochaine fois qu'il atterrit, on incrémente steps à nouveau.
     */
    public void resetStep(Player player) {
        if (!player.intersects(this)) {
            playerWasOn = false;
        }
    }
}
fin fichier ./src/model/platforms/FragilePlatform.java





début fichier ./src/model/Player.java
package src.model;

import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;

/**
 * Classe Player : gère la position, la vitesse, l'état (walking, jetpack, etc.)
 */
public class Player {
    private DoubleProperty x = new SimpleDoubleProperty();
    private DoubleProperty y = new SimpleDoubleProperty();
    private double width = 50;
    private double height = 50;
    public double velocityY = 0;
    public boolean onGround = false;
    private int jumps = 0;
    private static final int MAX_JUMPS = 2;
    private double speed = 180.0;
    private boolean jetpackActive = false;
    private boolean walking = false;

    // Propriété indiquant la direction : true = face à droite, false = face à gauche
    private boolean facingRight = true;

    public Player(double x, double y) {
        this.x.set(x);
        this.y.set(y);
    }

    public double getX() { return x.get(); }
    public void setX(double x) { this.x.set(x); }
    public DoubleProperty xProperty() { return x; }

    public double getY() { return y.get(); }
    public void setY(double y) { this.y.set(y); }
    public DoubleProperty yProperty() { return y; }

    public double getWidth() { return width; }
    public double getHeight() { return height; }

    public void move(double dx, double dy) {
        setX(getX() + dx);
        setY(getY() + dy);
        walking = (dx != 0);
    }

    public boolean isWalking() { return walking; }
    public void stopWalking() { walking = false; }

    public boolean intersects(Platform platform) {
        /*System.out.println("[DEBUG] Player intersects() -> "
            + "Player: x=" + getX() + ", y=" + getY()
            + ", w=" + getWidth() + ", h=" + getHeight()
            + " | Platform: x=" + platform.getX()
            + ", y=" + platform.getY()
            + ", w=" + platform.getWidth()
            + ", h=" + platform.getHeight());*/
        return getX() < platform.getX() + platform.getWidth()
            && getX() + getWidth() > platform.getX()
            && getY() < platform.getY() + platform.getHeight()
            && getY() + getHeight() > platform.getY();
    }

    public boolean intersects(Enemy enemy) {
        return getX() < enemy.getX() + enemy.getWidth()
            && getX() + getWidth() > enemy.getX()
            && getY() < enemy.getY() + enemy.getHeight()
            && getY() + getHeight() > enemy.getY();
    }

    public boolean landsOn(Enemy enemy) {
        return getX() < enemy.getX() + enemy.getWidth()
            && getX() + getWidth() > enemy.getX()
            && getY() + getHeight() >= enemy.getY()
            && getY() + getHeight() <= enemy.getY() + enemy.getHeight() / 2
            && velocityY > 0;
    }

    public int getJumps() { return jumps; }
    public void incrementJumps() { jumps++; }
    public void resetJumps() { jumps = 0; }
    public boolean canJump() { return jumps < MAX_JUMPS; }
    public double getSpeed() { return speed; }
    public void setSpeed(double speed) { this.speed = speed; }
    public boolean isJetpackActive() { return jetpackActive; }
    public void setJetpackActive(boolean jetpackActive) { this.jetpackActive = jetpackActive; }
    public void setVelocityY(double velocityY) { this.velocityY = velocityY; }
    public void setOnGround(boolean onGround) { this.onGround = onGround; }

    // Accesseurs pour la direction du joueur
    public boolean isFacingRight() {
        return facingRight;
    }

    public void setFacingRight(boolean facingRight) {
        this.facingRight = facingRight;
    }
}
fin fichier ./src/model/Player.java





début fichier ./src/model/Projectile.java
package src.model;

/**
 * Un projectile tiré par le vaisseau.
 */
public class Projectile {
    private double x, y;
    private static final double WIDTH  = 10;
    private static final double HEIGHT = 4;
    private static final double SPEED  = 360.0;
    private final boolean toRight;

    public Projectile(double x, double y, boolean toRight) {
        this.x       = x;
        this.y       = y;
        this.toRight = toRight;
    }

    /** Avance le projectile d’une frame. */
    /** @param deltaSec  temps écoulé (s) */
    public void update(double deltaSec) {
        x += (toRight ? 1 : -1) * SPEED * deltaSec;
    }


    /** Indique si le projectile est hors limites du niveau. */
    public boolean isOutOfBounds(double levelWidth) {
        return x + WIDTH < 0 || x > levelWidth;
    }

    /** Collision AABB basique avec un ennemi. */
    public boolean intersects(Enemy e) {
        return x < e.getX() + e.getWidth()
            && x + WIDTH  > e.getX()
            && y < e.getY() + e.getHeight()
            && y + HEIGHT > e.getY();
    }

    // Getters
    public double getX()      { return x; }
    public double getY()      { return y; }
    public double getWidth()  { return WIDTH; }
    public double getHeight() { return HEIGHT; }
}
fin fichier ./src/model/Projectile.java





début fichier ./src/test/SpaceshipTest.java
package test;

import javafx.animation.AnimationTimer;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.stage.Stage;
import javafx.scene.input.KeyCode;

/**
 * Exemple minimal : un "vaisseau" (cercle) qui se déplace
 * librement avec les flèches. Aucune gravité, aucune collision.
 */
public class SpaceshipTest extends Application {

    private double x = 100;   // Position initiale du "vaisseau"
    private double y = 300;
    private double speed = 3; // Vitesse de déplacement

    private boolean up, down, left, right;

    @Override
    public void start(Stage primaryStage) {
        Canvas canvas = new Canvas(800, 600);
        GraphicsContext gc = canvas.getGraphicsContext2D();

        StackPane root = new StackPane(canvas);
        Scene scene = new Scene(root, 800, 600);

        // Gestion des touches
        scene.setOnKeyPressed(e -> {
            if (e.getCode() == KeyCode.UP)    up    = true;
            if (e.getCode() == KeyCode.DOWN)  down  = true;
            if (e.getCode() == KeyCode.LEFT)  left  = true;
            if (e.getCode() == KeyCode.RIGHT) right = true;
        });
        scene.setOnKeyReleased(e -> {
            if (e.getCode() == KeyCode.UP)    up    = false;
            if (e.getCode() == KeyCode.DOWN)  down  = false;
            if (e.getCode() == KeyCode.LEFT)  left  = false;
            if (e.getCode() == KeyCode.RIGHT) right = false;
        });

        primaryStage.setTitle("Spaceship Test");
        primaryStage.setScene(scene);
        primaryStage.show();

        // Boucle de jeu : ~60 fps
        AnimationTimer timer = new AnimationTimer() {
            @Override
            public void handle(long now) {
                update();
                draw(gc);
            }
        };
        timer.start();
    }

    /**
     * Met à jour la position du "vaisseau".
     */
    private void update() {
        if (up)    y -= speed;
        if (down)  y += speed;
        if (left)  x -= speed;
        if (right) x += speed;
    }

    /**
     * Dessine la scène : efface l'écran et dessine un cercle.
     */
    private void draw(GraphicsContext gc) {
        gc.clearRect(0, 0, 800, 600);

        gc.setFill(Color.BLACK);
        gc.fillRect(0, 0, 800, 600);

        gc.setFill(Color.WHITE);
        gc.setFont(Font.font(18));
        gc.fillText("Use arrow keys to move the spaceship.\nX=" + x + ", Y=" + y, 20, 30);

        // Dessine un cercle comme "vaisseau"
        gc.setFill(Color.YELLOW);
        gc.fillOval(x, y, 40, 40);
    }

    public static void main(String[] args) {
        launch(args);
    }
}
fin fichier ./src/test/SpaceshipTest.java





début fichier ./src/view/GameView.java
// src/view/GameView.java
package src.view;

import javafx.application.Platform;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.scene.CacheHint;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.image.Image;
import javafx.scene.image.WritableImage;
import javafx.scene.paint.Color;

import java.util.List;
import java.util.concurrent.CountDownLatch;

import src.model.Enemy;
import src.model.Boss;

public class GameView {
    private final DoubleProperty cameraX = new SimpleDoubleProperty(0);
    private final DoubleProperty cameraY = new SimpleDoubleProperty(0);
    private final GraphicsContext gc;

    // Cache pour le background redimensionné
    private Image cachedBackground = null;
    private double cachedWidth = 0, cachedHeight = 0;

    // ------------------------------------------------------------
    // Engrenage
    // ------------------------------------------------------------
    private Image gearSpriteSheet;
    private int gearFrameIndex = 0;
    private int gearFrameCount = 0;
    private int gearFrameWidth = 0;
    private int gearFrameHeight = 0;
    private long lastGearFrameTime = 0;
    private final long gearFrameDuration = 50_000_000; // 50 ms

    // ------------------------------------------------------------
    // Joueur Idle
    // ------------------------------------------------------------
    private Image playerIdleSheet;
    private int idleFrameIndex = 0;
    private int idleFrameCount = 0;
    private int idleFrameWidth = 0;
    private int idleFrameHeight = 0;
    private long lastIdleFrameTime = 0;
    private final long idleFrameDuration = 100_000_000; // 100 ms

    // ------------------------------------------------------------
    // Joueur Walk
    // ------------------------------------------------------------
    private Image playerWalkSheet;
    private int walkFrameIndex = 0;
    private int walkFrameCount = 0;
    private int walkFrameWidth = 0;
    private int walkFrameHeight = 0;
    private long lastWalkFrameTime = 0;
    private final long walkFrameDuration = 100_000_000; // 100 ms

    // ------------------------------------------------------------
    // Joueur Jump
    // ------------------------------------------------------------
    private Image playerJumpSheet;
    private int jumpFrameIndex = 0;
    private int jumpFrameCount = 0;
    private int jumpFrameWidth = 0;
    private int jumpFrameHeight = 0;
    private long lastJumpFrameTime = 0;
    private final long jumpFrameDuration = 100_000_000; // 100 ms

    // ------------------------------------------------------------
    // Sprite du vaisseau
    // ------------------------------------------------------------
    private Image spaceshipImage;
    private final double playerOffsetY = 50;

    public GameView(GraphicsContext gc) {
        this.gc = gc;
        Canvas canvas = gc.getCanvas();
        canvas.setCache(true);
        canvas.setCacheHint(CacheHint.SPEED);

        try {
            // Engrenage
            gearSpriteSheet = new Image("file:../textures/engrenage_animation-Sheet.png");
            if (!gearSpriteSheet.isError()) {
                gearFrameHeight = (int) gearSpriteSheet.getHeight();
                gearFrameWidth  = gearFrameHeight;
                if (gearFrameWidth != 0) {
                    gearFrameCount = (int) (gearSpriteSheet.getWidth() / gearFrameWidth);
                }
            }

            // Joueur Idle
            playerIdleSheet = new Image("file:../textures/static wrench-Sheet.png");
            if (!playerIdleSheet.isError()) {
                idleFrameHeight = (int) playerIdleSheet.getHeight();
                idleFrameWidth  = idleFrameHeight;
                if (idleFrameWidth != 0) {
                    idleFrameCount = (int) (playerIdleSheet.getWidth() / idleFrameWidth);
                }
            }

            // Joueur Walk
            playerWalkSheet = new Image("file:../textures/sprite sheet wrench walking.png");
            if (!playerWalkSheet.isError()) {
                walkFrameHeight = (int) playerWalkSheet.getHeight();
                walkFrameWidth  = walkFrameHeight;
                if (walkFrameWidth != 0) {
                    walkFrameCount = (int) (playerWalkSheet.getWidth() / walkFrameWidth);
                }
            }

            // Joueur Jump
            playerJumpSheet = new Image("file:../textures/jump2 wrench-Sheet.png");
            if (!playerJumpSheet.isError()) {
                jumpFrameHeight = (int) playerJumpSheet.getHeight();
                jumpFrameWidth  = jumpFrameHeight;
                if (jumpFrameWidth != 0) {
                    jumpFrameCount = (int) (playerJumpSheet.getWidth() / jumpFrameWidth);
                }
            }

            // Sprite vaisseau
            spaceshipImage = new Image("file:../textures/dirigeable v1.png");
        } catch (Exception e) {
            System.err.println("Exception loading images: " + e.getMessage());
        }
    }

    /**
     * Retourne une version redimensionnée du background (thread-safe).
     */
    private Image getScaledBackground(Image background, double width, double height) {
        if (Platform.isFxApplicationThread()) {
            return createScaledBackground(background, width, height);
        } else {
            final Image[] result = new Image[1];
            final CountDownLatch latch = new CountDownLatch(1);
            Platform.runLater(() -> {
                result[0] = createScaledBackground(background, width, height);
                latch.countDown();
            });
            try {
                latch.await();
            } catch (InterruptedException ignored) {}
            return result[0];
        }
    }

    private Image createScaledBackground(Image background, double width, double height) {
        Canvas temp = new Canvas(width, height);
        GraphicsContext gc2 = temp.getGraphicsContext2D();
        gc2.drawImage(background, 0, 0, width, height);
        WritableImage wi = new WritableImage((int) width, (int) height);
        temp.snapshot(null, wi);
        return wi;
    }

    /**
     * Dessine la frame complète, avec décorations, plateformes, ennemis et projectiles.
     */
    public void draw(
        Image background,
        double playerX, double playerY,
        double playerW, double playerH,
        boolean isWalking, boolean facingRight,
        boolean isJumping, boolean spaceshipMode,
        List<Image> decorationImages,
        List<Double[]> decorationPositions,
        List<Image> platformImages,
        List<Double[]> platformPositions,
        List<Enemy> enemies,
        List<Double[]> projectilePositions
    ) {
        double cw = gc.getCanvas().getWidth();
        double ch = gc.getCanvas().getHeight();

        // Fond noir
        gc.setFill(Color.BLACK);
        gc.fillRect(0, 0, cw, ch);

        // Background mis à l’échelle + cache
        if (background != null) {
            if (cachedBackground == null || cachedWidth != cw || cachedHeight != ch) {
                cachedBackground = getScaledBackground(background, cw, ch);
                cachedWidth = cw; cachedHeight = ch;
            }
            gc.drawImage(cachedBackground, 0, 0);
        }

        // Engrenage
        if (gearSpriteSheet != null && gearFrameWidth > 0) {
            long now = System.nanoTime();
            if (now - lastGearFrameTime >= gearFrameDuration) {
                gearFrameIndex = (gearFrameIndex + 1) % gearFrameCount;
                lastGearFrameTime = now;
            }
            int sx = gearFrameIndex * gearFrameWidth;
            gc.drawImage(gearSpriteSheet,
                         sx, 0, gearFrameWidth, gearFrameHeight,
                         0, 0, gearFrameWidth, gearFrameHeight);
        }

        // 1) Décorations
        for (int i = 0; i < decorationImages.size(); i++) {
            Image img = decorationImages.get(i);
            Double[] pos = decorationPositions.get(i);
            double dx = pos[0] - cameraX.get();
            double dy = pos[1] - cameraY.get();
            double dw = pos[2], dh = pos[3];
            if (img != null) {
                gc.drawImage(img, dx, dy, dw, dh);
            }
        }

        // JOUEUR ou VAISSEAU
        double drawX = playerX - cameraX.get();
        double drawY = playerY - cameraY.get() - playerOffsetY;
        if (spaceshipMode && spaceshipImage != null) {
            double imageW = spaceshipImage.getWidth();
            double imageH = spaceshipImage.getHeight();
            double targetH = playerH * 2.0;
            double targetW = targetH * (imageW / imageH);

            if (facingRight) {
                gc.drawImage(spaceshipImage,
                             drawX, drawY,
                             targetW, targetH);
            } else {
                gc.save();
                gc.translate(drawX + targetW, drawY);
                gc.scale(-1, 1);
                gc.drawImage(spaceshipImage,
                             0, 0,
                             targetW, targetH);
                gc.restore();
            }
        } else if (isJumping && playerJumpSheet != null && jumpFrameWidth > 0) {
            long now = System.nanoTime();
            if (now - lastJumpFrameTime >= jumpFrameDuration) {
                jumpFrameIndex = (jumpFrameIndex + 1) % jumpFrameCount;
                lastJumpFrameTime = now;
            }
            int sx = jumpFrameIndex * jumpFrameWidth;
            if (facingRight) {
                gc.drawImage(playerJumpSheet,
                             sx, 0, jumpFrameWidth, jumpFrameHeight,
                             drawX, drawY, playerW * 2, playerH * 2);
            } else {
                gc.save();
                gc.translate(drawX + playerW * 2, drawY);
                gc.scale(-1, 1);
                gc.drawImage(playerJumpSheet,
                             sx, 0, jumpFrameWidth, jumpFrameHeight,
                             0, 0, playerW * 2, playerH * 2);
                gc.restore();
            }
        } else if (isWalking && playerWalkSheet != null && walkFrameWidth > 0) {
            long now = System.nanoTime();
            if (now - lastWalkFrameTime >= walkFrameDuration) {
                walkFrameIndex = (walkFrameIndex + 1) % walkFrameCount;
                lastWalkFrameTime = now;
            }
            int sx = walkFrameIndex * walkFrameWidth;
            if (facingRight) {
                gc.drawImage(playerWalkSheet,
                             sx, 0, walkFrameWidth, walkFrameHeight,
                             drawX, drawY, playerW * 2, playerH * 2);
            } else {
                gc.save();
                gc.translate(drawX + playerW * 2, drawY);
                gc.scale(-1, 1);
                gc.drawImage(playerWalkSheet,
                             sx, 0, walkFrameWidth, walkFrameHeight,
                             0, 0, playerW * 2, playerH * 2);
                gc.restore();
            }
        } else if (playerIdleSheet != null && idleFrameWidth > 0) {
            long now = System.nanoTime();
            if (now - lastIdleFrameTime >= idleFrameDuration) {
                idleFrameIndex = (idleFrameIndex + 1) % idleFrameCount;
                lastIdleFrameTime = now;
            }
            int sx = idleFrameIndex * idleFrameWidth;
            if (facingRight) {
                gc.drawImage(playerIdleSheet,
                             sx, 0, idleFrameWidth, idleFrameHeight,
                             drawX, drawY, playerW * 2, playerH * 2);
            } else {
                gc.save();
                gc.translate(drawX + playerW * 2, drawY);
                gc.scale(-1, 1);
                gc.drawImage(playerIdleSheet,
                             sx, 0, idleFrameWidth, idleFrameHeight,
                             0, 0, playerW * 2, playerH * 2);
                gc.restore();
            }
        }

        // 3) Plateformes
        for (int i = 0; i < platformImages.size(); i++) {
            Image img = platformImages.get(i);
            Double[] pos = platformPositions.get(i);
            double px = pos[0] - cameraX.get();
            double py = pos[1] - cameraY.get();
            double pw = pos[2], ph = pos[3];
            if (img != null) {
                gc.drawImage(img, px, py, pw, ph);
            } else {
                gc.setFill(Color.BLUE);
                gc.fillRect(px, py, pw, ph);
            }
        }

        // 4) Ennemis + boss
        for (Enemy e : enemies) {
            double ex = e.getX() - cameraX.get();
            double ey = e.getY() - cameraY.get();
            double ew = e.getWidth(), eh = e.getHeight();
            if (e instanceof Boss && ((Boss) e).isHit()) {
                gc.setFill(Color.RED);
            } else {
                gc.setFill(Color.GREEN);
            }
            gc.fillRect(ex, ey, ew, eh);
        }

        // 5) Projectiles (mode vaisseau)
        if (spaceshipMode) {
            gc.setFill(Color.RED);
            for (Double[] pos : projectilePositions) {
                double px = pos[0] - cameraX.get();
                double py = pos[1] - cameraY.get();
                double pw = pos[2], ph = pos[3];
                gc.fillRect(px, py, pw, ph);
            }
        }
    }

    public DoubleProperty cameraXProperty() { return cameraX; }
    public DoubleProperty cameraYProperty() { return cameraY; }
    public double getCanvasWidth()        { return gc.getCanvas().getWidth(); }
    public double getCanvasHeight()       { return gc.getCanvas().getHeight(); }

    public void resetBackgroundCache() {
        this.cachedBackground = null;
        this.cachedWidth  = -1;
        this.cachedHeight = -1;
    }
}
fin fichier ./src/view/GameView.java





début fichier ./.vscode/launch.json

{
"version": "0.2.0",
"configurations": [
    {
        "type": "java",
        "name": "Launch Game",
        "request": "launch",
        "mainClass": "src.Game",
        "vmArgs": "--module-path matthieu/Documents/zulu21.38.21-ca-fx-jdk21.0.5-linux_x64/lib --add-modules javafx.controls,javafx.fxml"
    }
]
}fin fichier ./.vscode/launch.json





